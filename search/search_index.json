{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Erg\u00e4nzungen zum C# Buch","text":"<p>Hier finden sie Erg\u00e4nzungen und \u00dcbungsaufgaben zum Buch</p> <p> Einstieg in C# mit Visual Studio 2022</p> <ul> <li> 2.4 Verzweigungen mit if und else</li> <li> 2.6 Verzweigungen und Steuerelemente</li> <li> 2.7 Schleifen</li> <li> 2.8 Schleifen und Steuerelemente</li> <li> 4.5 Methoden</li> </ul> <p> </p> <p>  LZK</p>"},{"location":"content/1/","title":"1 Einf\u00fchrung","text":"Erstes GUI \u2013 Label und zwei Buttons <p>Erstelle ein WinForms-Projekt, f\u00fcge ein Label <code>LblAnzeige</code> und zwei Buttons <code>CmdHallo</code>, <code>CmdEnde</code> ein.</p> <ul> <li> <p>Form-Text: \u201eMein erstes Projekt\u201c</p> </li> <li> <p><code>LblAnzeige</code> zun\u00e4chst leer, mit Rahmen (<code>FixedSingle</code>)</p> </li> </ul> L\u00f6sung <pre><code>// Eigenschaften per Designer setzen.\n// Optional per Code im Form_Load:\nprivate void Form1_Load(object sender, EventArgs e)\n{\n    this.Text = \"Mein erstes Projekt\";\n    LblAnzeige.Text = \"\";\n    LblAnzeige.BorderStyle = BorderStyle.FixedSingle;\n}\n</code></pre> Klick-Ereignisse \u2013 Hallo &amp; Ende <p>Erzeuge <code>CmdHallo_Click</code> und <code>CmdEnde_Click</code> per Doppelklick im Designer.</p> <ul> <li> <p><code>CmdHallo</code>: schreibe \u201eHallo, Welt!\u201c ins Label</p> </li> <li> <p><code>CmdEnde</code>: beende das Programm</p> </li> </ul> L\u00f6sung <pre><code>private void CmdHallo_Click(object sender, EventArgs e)\n{\n    LblAnzeige.Text = \"Hallo, Welt!\";\n}\n\nprivate void CmdEnde_Click(object sender, EventArgs e)\n{\n    Close();\n}\n</code></pre> Kommentare \u2013 einzeilig &amp; mehrzeilig <p>Erg\u00e4nze zu <code>CmdHallo_Click</code> sinnvolle Kommentare und setze dar\u00fcber einen mehrzeiligen Blockkommentar mit Zweck/Autor/Datum.</p> L\u00f6sung <pre><code>/*\n  Zweck: Schreibt einen Gru\u00df ins Label.\n  Autor: &lt;Dein Name&gt;\n  Datum: &lt;heute&gt;\n*/\nprivate void CmdHallo_Click(object sender, EventArgs e)\n{\n    // Schreibt Text ins Label\n    LblAnzeige.Text = \"Hallo, Welt!\";\n}\n</code></pre> ToString &amp; Interpolation <p>Lege <code>int x = 42;</code> an und gib aus:</p> <ul> <li> <p>erste Zeile: <code>x.ToString()</code></p> </li> <li> <p>zweite Zeile: <code>Wert: {x}</code> per Interpolation</p> </li> </ul> L\u00f6sung <pre><code>private void CmdHallo_Click(object sender, EventArgs e)\n{\n    int x = 42;\n    LblAnzeige.Text = x.ToString() + \"\\n\" + $\"Wert: {x}\";\n}\n</code></pre> MessageBox &amp; Laufzeit-Eigenschaften <p>Erzeuge einen Button <code>CmdInfo</code>, der</p> <ul> <li> <p>eine MessageBox mit zwei Zeilen zeigt</p> </li> <li> <p>danach <code>LblAnzeige</code> leert und Formtitel auf \u201eBereit\u201c setzt</p> </li> </ul> L\u00f6sung <pre><code>private void CmdInfo_Click(object sender, EventArgs e)\n{\n    string text = \"Erste Zeile\\nZweite Zeile\";\n    MessageBox.Show(text, \"Ausgabe\");\n    LblAnzeige.Text = string.Empty;\n    this.Text = \"Bereit\";\n}\n</code></pre>"},{"location":"content/10/","title":"10 Beispielprojekte","text":"Mini\u2011Spiel \u2013 Klick mich! <p>Erstelle ein kleines Spielchen: Ein Button springt zuf\u00e4llig in der Form herum, und der Benutzer soll ihn anklicken.</p> <p>Anforderungen</p> <ul> <li>Alle 800 ms setzt ein <code>Timer</code> die Position des Buttons neu.</li> <li>Beim erfolgreichen Klick erh\u00f6ht sich ein Punktez\u00e4hler.</li> <li>Nach 30 Sekunden wird das Spiel automatisch gestoppt und das Ergebnis angezeigt.</li> </ul> L\u00f6sung <pre><code>private int score = 0;\nprivate DateTime end;\n\nprivate void CmdStart_Click(object s, EventArgs e)\n{\n    score = 0;\n    end = DateTime.Now.AddSeconds(30);\n    Tmr.Interval = 800;\n    Tmr.Start();\n}\n\nprivate void Tmr_Tick(object s, EventArgs e)\n{\n    if (DateTime.Now &gt;= end) { Tmr.Stop(); MessageBox.Show($\"Punkte: {score}\"); return; }\n    var rnd = new Random();\n    Btn.Target.Left = rnd.Next(0, this.ClientSize.Width - Btn.Target.Width);\n    Btn.Target.Top  = rnd.Next(0, this.ClientSize.Height - Btn.Target.Height);\n}\n\nprivate void BtnTarget_Click(object s, EventArgs e) { score++; }\n</code></pre> Vokabeltrainer \u2013 Zufallsabfrage <p>Baue einen Mini\u2011Vokabeltrainer mit einem festen W\u00f6rterbuch im Code.</p> <p>Ablauf</p> <ul> <li>Per Button wird ein zuf\u00e4lliges Wort gew\u00e4hlt und angezeigt.</li> <li>Der Nutzer tippt die \u00dcbersetzung in eine TextBox.</li> <li>Nach Klick auf \u201ePr\u00fcfen\u201c gibt es Feedback und die n\u00e4chste Runde beginnt.</li> </ul> L\u00f6sung <pre><code>private readonly (string de, string en)[] words =\n{\n    (\"Hund\",\"dog\"), (\"Katze\",\"cat\"), (\"Haus\",\"house\")\n};\nprivate int idx = -1;\n\nprivate void CmdNext_Click(object s, EventArgs e)\n{\n    idx = new Random().Next(words.Length);\n    LblFrage.Text = words[idx].de;\n    TxtAntwort.Text = \"\";\n}\n\nprivate void CmdCheck_Click(object s, EventArgs e)\n{\n    if (idx &lt; 0) return;\n    bool ok = string.Equals(TxtAntwort.Text.Trim(), words[idx].en, StringComparison.OrdinalIgnoreCase);\n    MessageBox.Show(ok ? \"Richtig!\" : $\"Falsch \u2013 {words[idx].en}\");\n    CmdNext_Click(s, e);\n}\n</code></pre>"},{"location":"content/11/","title":"11 WPF","text":"WPF \u2013 Grid\u2011Layout mit zwei Spalten <p>Erstelle ein WPF\u2011Fenster mit <code>Grid</code> und zwei Spalten.</p> <p>Layout</p> <ul> <li>Linke Spalte fix 200 px, rechte Spalte <code>*</code></li> <li>Oben eine <code>TextBox</code> \u00fcber beide Spalten</li> <li>Unten zwei Buttons (links/rechts)</li> </ul> L\u00f6sung <pre><code>&lt;Window xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Layout\" Height=\"300\" Width=\"500\"&gt;\n  &lt;Grid&gt;\n    &lt;Grid.RowDefinitions&gt;\n      &lt;RowDefinition Height=\"Auto\"/&gt;\n      &lt;RowDefinition Height=\"*\"/&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n      &lt;ColumnDefinition Width=\"200\"/&gt;\n      &lt;ColumnDefinition Width=\"*\"/&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBox Grid.Row=\"0\" Grid.ColumnSpan=\"2\" Margin=\"8\"/&gt;\n\n    &lt;Button Grid.Row=\"1\" Grid.Column=\"0\" Margin=\"8\" Content=\"Links\"/&gt;\n    &lt;Button Grid.Row=\"1\" Grid.Column=\"1\" Margin=\"8\" Content=\"Rechts\"/&gt;\n  &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre> WPF \u2013 Datenbindung an Slider <p>Binde die <code>FontSize</code> eines TextBlocks an den Wert eines Sliders.</p> <p>Anforderungen</p> <ul> <li>Slider Minimum 8, Maximum 48</li> <li>Bidirektionale Bindung (<code>Mode=TwoWay</code>)</li> </ul> L\u00f6sung <pre><code>&lt;Window xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Binding\" Height=\"200\" Width=\"400\"&gt;\n  &lt;StackPanel Margin=\"12\"&gt;\n    &lt;Slider x:Name=\"Sizer\" Minimum=\"8\" Maximum=\"48\" Value=\"16\"/&gt;\n    &lt;TextBlock Text=\"Hello WPF\" FontSize=\"{Binding ElementName=Sizer, Path=Value, Mode=TwoWay}\" /&gt;\n  &lt;/StackPanel&gt;\n&lt;/Window&gt;\n</code></pre> WPF \u2013 Commands mit Buttons <p>Verbinde einen Button mit <code>ApplicationCommands.Copy</code> und reagiere im Code\u2011Behind.</p> L\u00f6sung <pre><code>&lt;Window x:Class=\"Demo.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Commands\" Height=\"200\" Width=\"300\"&gt;\n  &lt;Window.CommandBindings&gt;\n    &lt;CommandBinding Command=\"ApplicationCommands.Copy\"\n                    Executed=\"Copy_Executed\"\n                    CanExecute=\"Copy_CanExecute\"/&gt;\n  &lt;/Window.CommandBindings&gt;\n  &lt;StackPanel&gt;\n    &lt;Button Command=\"ApplicationCommands.Copy\" Content=\"Kopieren\" Margin=\"8\"/&gt;\n  &lt;/StackPanel&gt;\n&lt;/Window&gt;\n</code></pre> <pre><code>private void Copy_CanExecute(object sender, CanExecuteRoutedEventArgs e) { e.CanExecute = true; }\nprivate void Copy_Executed(object sender, ExecutedRoutedEventArgs e) { MessageBox.Show(\"Copy!\"); }\n</code></pre> WPF \u2013 ItemsControl mit Datenliste <p>Zeige eine Liste von Personen in einem <code>ItemsControl</code> mit einem <code>DataTemplate</code> an.</p> L\u00f6sung <pre><code>&lt;Window x:Class=\"Demo.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Items\" Height=\"300\" Width=\"400\"&gt;\n  &lt;StackPanel&gt;\n    &lt;ItemsControl x:Name=\"People\"&gt;\n      &lt;ItemsControl.ItemTemplate&gt;\n        &lt;DataTemplate&gt;\n          &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;TextBlock Text=\"{Binding Name}\" Margin=\"0,0,8,0\"/&gt;\n            &lt;TextBlock Text=\"{Binding Geburtsjahr}\"/&gt;\n          &lt;/StackPanel&gt;\n        &lt;/DataTemplate&gt;\n      &lt;/ItemsControl.ItemTemplate&gt;\n    &lt;/ItemsControl&gt;\n  &lt;/StackPanel&gt;\n&lt;/Window&gt;\n</code></pre> <pre><code>public partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n        People.ItemsSource = new []\n        {\n            new Person(\"Alex\",1992), new Person(\"Sam\",1988)\n        };\n    }\n}\n</code></pre> WPF \u2013 Animation mit Storyboard <p>Animiere die <code>Opacity</code> eines Buttons zwischen 0.2 und 1.0 im Ping\u2011Pong\u2011Modus.</p> L\u00f6sung <pre><code>&lt;Window xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Anim\" Height=\"200\" Width=\"300\"&gt;\n  &lt;Grid&gt;\n    &lt;Button x:Name=\"Blink\" Content=\"Blink\" Width=\"120\" Height=\"40\"&gt;\n      &lt;Button.Triggers&gt;\n        &lt;EventTrigger RoutedEvent=\"Loaded\"&gt;\n          &lt;BeginStoryboard&gt;\n            &lt;Storyboard AutoReverse=\"True\" RepeatBehavior=\"Forever\"&gt;\n              &lt;DoubleAnimation Storyboard.TargetProperty=\"Opacity\"\n                               From=\"0.2\" To=\"1.0\" Duration=\"0:0:1\"/&gt;\n            &lt;/Storyboard&gt;\n          &lt;/BeginStoryboard&gt;\n        &lt;/EventTrigger&gt;\n      &lt;/Button.Triggers&gt;\n    &lt;/Button&gt;\n  &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre> WPF \u2013 Navigation zwischen Seiten <p>Verwende ein <code>Frame</code>, um zwischen zwei <code>Page</code>\u2011Seiten zu navigieren.</p> <p>Hinweis</p> <ul> <li>Lade die erste Seite im <code>Loaded</code>\u2011Ereignis.</li> <li>Navigiere per Button\u2011Klick zur zweiten Seite.</li> </ul> L\u00f6sung <pre><code>&lt;Window x:Class=\"Demo.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Nav\" Height=\"300\" Width=\"400\" Loaded=\"Window_Loaded\"&gt;\n  &lt;DockPanel&gt;\n    &lt;StackPanel DockPanel.Dock=\"Top\" Orientation=\"Horizontal\"&gt;\n      &lt;Button Content=\"Seite 1\" Click=\"Btn1_Click\" Margin=\"4\"/&gt;\n      &lt;Button Content=\"Seite 2\" Click=\"Btn2_Click\" Margin=\"4\"/&gt;\n    &lt;/StackPanel&gt;\n    &lt;Frame x:Name=\"MainFrame\"/&gt;\n  &lt;/DockPanel&gt;\n&lt;/Window&gt;\n</code></pre> <pre><code>private void Window_Loaded(object sender, RoutedEventArgs e) =&gt; MainFrame.Navigate(new Page1());\nprivate void Btn1_Click(object s, RoutedEventArgs e) =&gt; MainFrame.Navigate(new Page1());\nprivate void Btn2_Click(object s, RoutedEventArgs e) =&gt; MainFrame.Navigate(new Page2());\n</code></pre>"},{"location":"content/2/","title":"2.4 Verzweigungen mit if und else","text":""},{"location":"content/2/#24-verzweigungen-mit-if-und-else","title":"2.4 Verzweigungen mit if und else","text":"if/else \u2013 Temperaturklassifikation <p>Lies eine Temperatur aus einem NumericUpDown (z. B. <code>NumTemp</code>) und gib im Label aus:</p> <ul> <li><code>&lt; 0</code> \u2192 \u201eFrost\u201c</li> <li><code>== 0</code> \u2192 \u201eGefrierpunkt\u201c</li> <li><code>&gt; 0</code> \u2192 \u201ePlusgrade\u201c</li> </ul> L\u00f6sung <pre><code>decimal t = NumTemp.Value;\n\nif (t &lt; 0)\n{\n    LblAnzeige.Text = \"Frost\";\n}\nelse if (t == 0)\n{\n    LblAnzeige.Text = \"Gefrierpunkt\";\n}\nelse\n{\n    LblAnzeige.Text = \"Plusgrade\";\n}\n</code></pre> if/else \u2013 Notentext (1\u20136) <p>Lies eine Note <code>1</code>\u2013<code>6</code> (z. B. <code>NumNote</code>) und gib per <code>if/else if/else</code> den Text aus:</p> <ul> <li>1 \u201esehr gut\u201c, 2 \u201egut\u201c, 3 \u201ebefriedigend\u201c, 4 \u201eausreichend\u201c, 5 \u201emangelhaft\u201c, 6 \u201eungen\u00fcgend\u201c.</li> </ul> L\u00f6sung <pre><code>int note = (int)NumNote.Value;\nstring text;\n\nif (note == 1)\n{\n    text = \"sehr gut\";\n}\nelse if (note == 2)\n{\n    text = \"gut\";\n}\nelse if (note == 3)\n{\n    text = \"befriedigend\";\n}\nelse if (note == 4)\n{\n    text = \"ausreichend\";\n}\nelse if (note == 5)\n{\n    text = \"mangelhaft\";\n}\nelse\n{\n    text = \"ungen\u00fcgend\";\n}\n\nLblAnzeige.Text = text;\n</code></pre> Tern\u00e4rer Operator \u2013 gerade/ungerade <p>Lies eine Ganzzahl (NumericUpDown, z. B. <code>NumZahl</code>, <code>DecimalPlaces=0</code>) und gib \u201egerade\u201c/\u201eungerade\u201c mit <code>?:</code> aus.</p> Tipp <p>Mit hilfe des <code>%</code>-Operators kann man bestimmen, ob eine Zahl gerade oder ungerade ist. Rechachiere wie das geht!</p> L\u00f6sung <pre><code>int n = (int)NumZahl.Value;\nstring text = (n % 2 == 0) ? \"gerade\" : \"ungerade\";\nLblAnzeige.Text = text;\n</code></pre> if/else \u2013 Wertebereiche <p>Lies einen Wert \u221210\u2026+10 (<code>NumWert</code>). Gib aus:</p> <ul> <li><code>&lt; 0</code> \u2192 \u201enegativ\u201c</li> <li><code>== 0</code> \u2192 \u201enull\u201c</li> <li><code>&gt; 0 &amp;&amp; &lt;= 9</code> \u2192 \u201epositiv, einstellig\u201c</li> <li><code>&gt;= 10</code> \u2192 \u201epositiv und mindestens zweistellig\u201c</li> </ul> L\u00f6sung <pre><code>int v = (int)NumWert.Value;\nstring text;\n\nif (v &lt; 0)\n{\n    text = \"negativ\";\n}\nelse if (v == 0)\n{\n    text = \"null\";\n}\nelse if (v &gt; 0 &amp;&amp; v &lt;= 9)\n{\n    text = \"positiv, einstellig\";\n}\nelse\n{\n    text = \"positiv und mindestens zweistellig\";\n}\n\n\nLblAnzeige.Text = text;\n</code></pre>"},{"location":"content/2_6/","title":"2.6 Verzweigungen und Steuerelemente","text":""},{"location":"content/2_6/#261-steuerelement-checkbox","title":"2.6.1 Steuerelement Checkbox","text":"Eine Checkbox <p>Erstelle eine Checkbox mit den Text \"Zustimmen\". Erstelle ein Label mit dem schwarzen Text: \"Wir ben\u00f6tigen ihre Zustimmung\".</p> <p>Finde heraus, wie du die Farbe eines Textes \u00e4ndern kannst.</p> <p>Sorge daf\u00fcr, dass wenn du die Checkbox aktivierst, der Text gr\u00fcn wird und lautet \"Danke f\u00fcr Ihre Zustimmung!\".</p> <p>Wenn die Checkbox deaktiviert wird, dann soll wieder der urspr\u00fcngliche schwarze Text erscheinen.</p> <p>Bonus: Speichere die Farben und Texte in Konstanten.</p> Tipp <p>Textfarbe \u00e4ndern:</p> <pre><code>LblHinweis.ForeColor = Color.Green; // oder Color.Black\n</code></pre> L\u00f6sung <pre><code>namespace DeineApp\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n\n            // Anfangszustand sicherstellen\n            LblHinweis.Text = \"Wir ben\u00f6tigen ihre Zustimmung\";\n            LblHinweis.ForeColor = Color.Black;\n\n        }\n\n        private void ChkZustimmen_CheckedChanged(object sender, EventArgs e)\n        {\n            if (ChkZustimmen.Checked)\n            {\n                LblHinweis.Text = \"Danke f\u00fcr Ihre Zustimmung!\";\n                LblHinweis.ForeColor = Color.Green;\n            }\n            else\n            {\n                LblHinweis.Text = \"Wir ben\u00f6tigen ihre Zustimmung\";\n                LblHinweis.ForeColor = Color.Black;\n            }\n        }\n    }\n}\n</code></pre> <p>L\u00f6sung mit Bonus:</p> <pre><code>namespace DeineApp\n{\n    public partial class Form1 : Form\n    {\n        // Texte als Konstanten\n        private const string TEXT_DEFAULT = \"Wir ben\u00f6tigen ihre Zustimmung\";\n        private const string TEXT_OK      = \"Danke f\u00fcr Ihre Zustimmung!\";\n\n        // Farben als schreibgesch\u00fctzte Felder\n        private static readonly Color COLOR_DEFAULT = Color.Black;\n        private static readonly Color COLOR_OK      = Color.Green;\n\n        public Form1()\n        {\n            InitializeComponent();\n\n            // Anfangszustand\n            LblHinweis.Text = TEXT_DEFAULT;\n            LblHinweis.ForeColor = COLOR_DEFAULT;\n        }\n\n        private void ChkZustimmen_CheckedChanged(object sender, EventArgs e)\n        {\n            if (ChkZustimmen.Checked)\n            {\n                LblHinweis.Text = TEXT_OK;\n                LblHinweis.ForeColor = COLOR_OK;\n            }\n            else\n            {\n                LblHinweis.Text = TEXT_DEFAULT;\n                LblHinweis.ForeColor = COLOR_DEFAULT;\n            }\n        }\n    }\n}\n</code></pre> Zwei Checkboxen, zwei Buttons <p>Erstelle zwei Checkboxen und zwei Buttons.</p> <p>Sorge daf\u00fcr, dass der erste Button nur dann klickbar ist, wenn mindestens einer der beiden Checkboxen einen Haken hat.</p> <p>Sorge weiter daf\u00fcr, dass der zweite Button nur dann klickbar ist, wenn beide Checkboxen einen Haken haben.</p> L\u00f6sung <p>WinForms (VS 2022)</p> <p>Benennung im Designer Setze im Eigenschaftenfenster die Namen:</p> <ul> <li><code>ChkLinks</code>, <code>ChkRechts</code> (CheckBox)</li> <li><code>CmdErster</code>, <code>CmdZweiter</code> (Button)</li> </ul> <pre><code>namespace DeineApp\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void ChkLinks_CheckedChanged(object sender, EventArgs e)\n        {\n            CmdErster.Enabled = ChkLinks.Checked || ChkRechts.Checked;\n            CmdZweiter.Enabled = ChkLinks.Checked &amp;&amp; ChkRechts.Checked;\n        }\n\n        private void ChkRechts_CheckedChanged(object sender, EventArgs e)\n        {\n            CmdErster.Enabled = ChkLinks.Checked || ChkRechts.Checked;\n            CmdZweiter.Enabled = ChkLinks.Checked &amp;&amp; ChkRechts.Checked;\n        }\n\n        private void CmdErster_Click(object sender, EventArgs e)\n        {\n            MessageBox.Show(\"Erster Button geklickt.\");\n        }\n\n        private void CmdZweiter_Click(object sender, EventArgs e)\n        {\n            MessageBox.Show(\"Zweiter Button geklickt.\");\n        }\n    }\n}\n</code></pre> Versteckter Knopf <p>Erstelle zwei Checkboxen.</p> <p>Sorge daf\u00fcr, dass man zu Beginn nur eine von den zwei Boxen nutzen kann.</p> <p>Sobald die erste Checkbox aktiviert wurde, kann auch die andere Checkbox angeklickt werden.</p> <p>Wenn die zweite Checkbox aktiviert wurde, dann erscheint ein bisher unsichtbarer Button. Wenn auf diesen Button geklickt wird, wird das Programm geschlossen.</p> L\u00f6sung <p>WinForms (VS 2022)</p> <p>Benennung im Designer - CheckBox 1: <code>ChkErste</code> (Text z. B. Erste Option) - CheckBox 2: <code>ChkZweite</code> (Text z. B. Zweite Option) - Button: <code>CmdBeenden</code> (Text: Beenden)</p> <p>Startzustand (im Designer setzen oder im Code unten): - <code>ChkZweite.Enabled = false</code> - <code>CmdBeenden.Visible = false</code></p> <p>Form1.cs <pre><code>namespace DeineApp\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        // Sobald die erste Checkbox AKTIV ist, darf die zweite benutzt werden.\n        private void ChkErste_CheckedChanged(object sender, EventArgs e)\n        {\n            ChkZweite.Enabled = ChkErste.Checked;\n            if (!ChkZweite.Enabled)\n            {\n                // Wenn wieder gesperrt, zweite abw\u00e4hlen und Button verstecken\n                ChkZweite.Checked = false;\n                CmdBeenden.Visible = false;\n            }\n        }\n\n        // Wenn die zweite Checkbox aktiviert wird, erscheint der Button.\n        // (Deaktivieren blendet ihn wieder aus.)\n        private void ChkZweite_CheckedChanged(object sender, EventArgs e)\n        {\n            CmdBeenden.Visible = ChkZweite.Checked;\n        }\n\n        // Button schlie\u00dft die Anwendung.\n        private void CmdBeenden_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n    }\n}\n</code></pre></p> Vier Checkboxen \u2013 \u201eAlle ausw\u00e4hlen\u201c <p>Erstelle vier Checkboxen. Die erste Checkbox erh\u00e4lt den Text \u201eAlle ausw\u00e4hlen\u201c.</p> <p>Programmiere die erste Checkbox so, dass wenn sie aktiviert wird, auch alle anderen Checkboxen aktiviert werden (und beim Deaktivieren alle anderen wieder deaktiviert werden).</p> L\u00f6sung <p>WinForms (VS 2022)</p> <p>Benennung im Designer - CheckBox 1: <code>ChkAlleAuswaehlen</code> (Text: Alle ausw\u00e4hlen) - CheckBox 2: <code>ChkOption1</code> (Text z. B. Option 1) - CheckBox 3: <code>ChkOption2</code> (Text z. B. Option 2) - CheckBox 4: <code>ChkOption3</code> (Text z. B. Option 3)</p> <p>Form1.cs <pre><code>namespace DeineApp\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n\n            // Anfangszustand (optional)\n            ChkAlleAuswaehlen.Checked = false;\n            ChkOption1.Checked = false;\n            ChkOption2.Checked = false;\n            ChkOption3.Checked = false;\n        }\n\n        // \"Alle ausw\u00e4hlen\" steuert die \u00fcbrigen Checkboxen\n        private void ChkAlleAuswaehlen_CheckedChanged(object sender, EventArgs e)\n        {\n            bool state = ChkAlleAuswaehlen.Checked;\n            ChkOption1.Checked = state;\n            ChkOption2.Checked = state;\n            ChkOption3.Checked = state;\n        }\n    }\n}\n</code></pre></p>"},{"location":"content/2_6/#262-steuerlement-radiobutton","title":"2.6.2 Steuerlement Radiobutton","text":"3 Radio Buttons - 3 Funktionen <p>Erstelle drei Radiobuttons und ein Label. Sorge daf\u00fcr, dass sich die Farbe des Textes \u00e4ndert, wenn man einen der Radiobuttons klickt.</p> <p>Baue die L\u00f6sung dabei so, dass jeder Button eine eigene Funktion hat.</p> L\u00f6sung <pre><code>// Angenommene Namen:\n//   RadioButtons: RbRot, RbGruen, RbBlau\n//   Label:        LblText\n// Jeder RadioButton hat seine eigene Ereignisfunktion (CheckedChanged).\n\nprivate void RbRot_CheckedChanged(object sender, EventArgs e)\n{\n    if (RbRot.Checked) LblText.ForeColor = Color.Red;\n}\n\nprivate void RbGruen_CheckedChanged(object sender, EventArgs e)\n{\n    if (RbGruen.Checked) LblText.ForeColor = Color.Green;\n}\n\nprivate void RbBlau_CheckedChanged(object sender, EventArgs e)\n{\n    if (RbBlau.Checked) LblText.ForeColor = Color.Blue;\n}\n</code></pre> 3 Radio Buttons deaktivieren <p>Erstelle zwei Radiobuttons.</p> <p>Erstelle einen Button, der daf\u00fcr sorgt, dass keiner der zwei Radiobuttons ausgew\u00e4hlt ist.</p> <p>Erstelle einen weiteren Button. Konfiguriere ihn so, dass er nur dann anklickbar ist, einer der Radiobuttons ausgew\u00e4hlt ist.</p> L\u00f6sung <pre><code>// Angenommene Namen:\n//   RadioButtons: RbA, RbB\n//   Button zum Leeren: BtnLeeren\n//   Nur-aktiv-wenn-ausgew\u00e4hlt-Button: BtnAktion\n// Hinweis: Setze im Designer anfangs BtnAktion.Enabled = false.\n\nprivate void RbA_CheckedChanged(object sender, EventArgs e)\n{\n    // Aktivierbar nur, wenn mind. einer ausgew\u00e4hlt ist.\n    if (RbA.Checked || RbB.Checked)\n    {\n        BtnAktion.Enabled = true;\n    }\n    else\n    {\n        BtnAktion.Enabled = false;\n    }\n}\n\nprivate void RbB_CheckedChanged(object sender, EventArgs e)\n{\n    // Gleiche Logik wie oben (kein Extra-Helfer, wie gefordert bis hierhin).\n    if (RbA.Checked || RbB.Checked)\n    {\n        BtnAktion.Enabled = true;\n    }\n    else\n    {\n        BtnAktion.Enabled = false;\n    }\n}\n\nprivate void BtnLeeren_Click(object sender, EventArgs e)\n{\n    // Beide Radiobuttons abw\u00e4hlen -&gt; nichts ausgew\u00e4hlt.\n    RbA.Checked = false;\n    RbB.Checked = false;\n\n    // Konsistent: Aktion-Button ist nun nicht anklickbar.\n    BtnAktion.Enabled = false;\n}\n</code></pre> Textfeld aktivieren <p>Erstelle drei Radiobuttons mit den Texten \"Herr\", \"Frau\", \"Frei w\u00e4hlbar\".</p> <p>Erstellen Sie eine Textbox neben den dritten Radiobutton. Konfiguriere diesen so,  dass man nur in diesen schreiben kann, wenn \"Frei w\u00e4hlbar\" ausgew\u00e4hlt ist.</p> <p>Erstelle eine weitere Textbox f\u00fcr deinen Namen.</p> <p>Erstelle einen Button mit dem Text \"Gr\u00fc\u00df mich\", der Nutzer mit seinem Namen und der gew\u00fcnschten Anrede anspricht.</p> L\u00f6sung <pre><code>// Angenommene Namen:\n//   RbHerr, RbFrau, RbFrei  (alle -&gt; CheckedChanged = RbAnrede_CheckedChanged)\n//   TbFrei (Enabled = false), TbName, BtnGruesMich (-&gt; Click), LblGruss\n\nprivate void RbAnrede_CheckedChanged(object sender, EventArgs e)\n{\n    TbFrei.Enabled = RbFrei.Checked;\n}\n\nprivate void BtnGruesMich_Click(object sender, EventArgs e)\n{\n    string anrede = \"Herr\";\n    if (RbFrau.Checked) { anrede = \"Frau\"; }\n    if (RbFrei.Checked) { anrede = TbFrei.Text; }\n\n    LblGruss.Text = $\"Hallo {anrede} {TbName.Text}!\";\n}\n</code></pre>"},{"location":"content/2_6/#263-gemeinsame-methode-fur-mehrere-ereignisse","title":"2.6.3 Gemeinsame Methode f\u00fcr mehrere Ereignisse","text":"3 Radio Buttons - 1 Funktion <p>Erstelle drei Radiobuttons und ein Label. Sorge daf\u00fcr, dass sich die Farbe des Textes \u00e4ndert, wenn man einen der Radiobuttons klickt.</p> <p>Baue die L\u00f6sung dabei so, dass alle Buttons die gleiche Funktion benutzen .</p> L\u00f6sung <pre><code>// Angenommene Namen:\n//   RadioButtons: RbRot, RbGruen, RbBlau  (alle -&gt; CheckedChanged = RbFarbe_CheckedChanged)\n//   Label:        LblText\n\nprivate void RbFarbe_CheckedChanged(object sender, EventArgs e)\n{\n    // Ein und dieselbe Funktion f\u00fcr alle drei RadioButtons.\n    RadioButton rb = (RadioButton)sender;\n\n    if (!rb.Checked)\n    {\n        return;\n    }\n\n    if (rb == RbRot)\n    {\n        LblText.ForeColor = Color.Red;\n    }\n    else if (rb == RbGruen)\n    {\n        LblText.ForeColor = Color.Green;\n    }\n    else if (rb == RbBlau)\n    {\n        LblText.ForeColor = Color.Blue;\n    }\n}\n</code></pre>"},{"location":"content/2_6/#264-steuerelement-groupbox","title":"2.6.4 Steuerelement GroupBox","text":"2 GroupBoxen \u2013 Kontakt &amp; Versand <p>Erstelle ein kleines Formular mit zwei GroupBoxen.</p> <p>1) GroupBox \u201eKontakt\u201c (<code>GbxKontakt</code>)</p> <ul> <li>Zwei RadioButtons: <code>RbMail</code> (Text: \u201eE-Mail\u201c) und <code>RbTelefon</code> (Text: \u201eTelefon\u201c).</li> </ul> <p>2) GroupBox \u201eVersand\u201c (<code>GbxVersand</code>)</p> <ul> <li>Zwei RadioButtons: <code>RbStandard</code> (Text: \u201eStandard\u201c) und <code>RbExpress</code> (Text: \u201eExpress\u201c).</li> </ul> <p>3) Auswertung</p> <ul> <li> <p>Ein Button <code>BtnAuswerten</code> (Text: \u201eAuswahl anzeigen\u201c).</p> </li> <li> <p>Ein Label <code>LblAusgabe</code> (leer).</p> </li> <li> <p>Beim Klick auf den Button soll im Label stehen, welche Kontaktart und welche Versandart gew\u00e4hlt wurden, z. B.: <code>Kontakt: E-Mail | Versand: Express</code>.</p> </li> <li> <p>Starte ohne Vorauswahl.</p> </li> <li> <p>Der Button <code>BtnAuswerten</code> ist nur anklickbar, wenn in beiden GroupBoxen jeweils eine Option gew\u00e4hlt wurde.</p> </li> </ul> L\u00f6sung <pre><code>// Angenommene Namen:\n//   GroupBoxen: GbxKontakt, GbxVersand\n//   RadioButtons: RbMail, RbTelefon, RbStandard, RbExpress\n//   Button: BtnAuswerten\n//   Label: LblAusgabe\n// Hinweise: Setze im Designer anfangs BtnAuswerten.Enabled = false.\n//           Starte ohne Vorauswahl (alle RadioButtons: Checked = false).\n\n// Allen vier RadioButtons im Designer dasselbe Ereignis zuweisen:\n// CheckedChanged = Rb_CheckedChanged\n\nprivate void Rb_CheckedChanged(object sender, EventArgs e)\n{\n    bool kontaktGew\u00e4hlt = RbMail.Checked || RbTelefon.Checked;\n    bool versandGew\u00e4hlt = RbStandard.Checked || RbExpress.Checked;\n    BtnAuswerten.Enabled = kontaktGew\u00e4hlt &amp;&amp; versandGew\u00e4hlt;\n}\n\nprivate void BtnAuswerten_Click(object sender, EventArgs e)\n{\n    // Button ist nur aktiv, wenn in beiden Gruppen etwas gew\u00e4hlt ist.\n    string kontakt = RbMail.Checked ? \"E-Mail\" : \"Telefon\";\n    string versand = RbExpress.Checked ? \"Express\" : \"Standard\";\n    LblAusgabe.Text = $\"Kontakt: {kontakt} | Versand: {versand}\";\n}\n</code></pre> Checkbox zeigt GroupBox mit 2 Optionen <p>Erstelle eine CheckBox <code>ChkZusatz</code> (Text: \u201eZusatzoptionen anzeigen\u201c).</p> <p>Erstelle eine GroupBox <code>GbxZusatz</code> (Text: \u201eZusatzoptionen\u201c) mit zwei RadioButtons:</p> <ul> <li> <p><code>RbA</code> (Text: \u201eOption A\u201c) \u2013 soll vorausgew\u00e4hlt sein.</p> </li> <li> <p><code>RbB</code> (Text: \u201eOption B\u201c).</p> </li> </ul> <p>Erstelle ein immer sichtbares Label <code>LblAuswahl</code>, das die aktuelle Auswahl beschreibt.</p> <p>Starte so:</p> <ul> <li> <p><code>GbxZusatz.Visible = false</code></p> </li> <li> <p><code>RbA.Checked = true</code> (Vorauswahl)</p> </li> <li> <p><code>LblAuswahl.Text = \"Auswahl: (deaktiviert)\"</code></p> </li> </ul> <p>Verhalten:</p> <ul> <li> <p>Wenn <code>ChkZusatz</code> angehakt wird \u2192 <code>GbxZusatz</code> sichtbar und <code>LblAuswahl</code> zeigt die aktuell ausgew\u00e4hlte Option.</p> </li> <li> <p>Wenn <code>ChkZusatz</code> abgew\u00e4hlt wird \u2192 <code>GbxZusatz</code> unsichtbar und <code>LblAuswahl</code> zeigt \u201e(deaktiviert)\u201c.</p> </li> <li> <p>Beim Umschalten zwischen <code>RbA</code> und <code>RbB</code> wird <code>LblAuswahl</code> entsprechend aktualisiert.</p> </li> </ul> L\u00f6sung <pre><code>// Angenommene Namen und Verdrahtung:\n//   CheckBox:   ChkZusatz          (CheckedChanged = ChkZusatz_CheckedChanged)\n//   GroupBox:   GbxZusatz          (Visible = false)\n//   RadioBtns:  RbA, RbB           (beide CheckedChanged = RbOption_CheckedChanged)\n//   Label:      LblAuswahl         (Text = \"Auswahl: (deaktiviert)\")\n//   Designer:   RbA.Checked = true (Vorauswahl)\n\nprivate void ChkZusatz_CheckedChanged(object sender, EventArgs e)\n{\n    GbxZusatz.Visible = ChkZusatz.Checked;\n\n    if (ChkZusatz.Checked)\n    {\n        // Zeige die aktuell gew\u00e4hlte Option (RbA ist standardm\u00e4\u00dfig vorausgew\u00e4hlt)\n        LblAuswahl.Text = $\"Auswahl: {(RbA.Checked ? RbA.Text : RbB.Text)}\";\n    }\n    else\n    {\n        LblAuswahl.Text = \"Auswahl: (deaktiviert)\";\n    }\n}\n\nprivate void RbOption_CheckedChanged(object sender, EventArgs e)\n{\n    RadioButton rb = (RadioButton)sender;\n    if (!rb.Checked)\n    {\n        return;\n    }\n\n    // Nur aktualisieren, wenn die Zusatz-Optionen sichtbar sind\n    if (GbxZusatz.Visible)\n    {\n        LblAuswahl.Text = $\"Auswahl: {rb.Text}\";\n    }\n}\n</code></pre>"},{"location":"content/2_7/","title":"2.7 Schleifen","text":"for \u2013 Summe 1..n <p>Nutze ein NumericUpDown, um eine Zahl <code>n</code> auszulesen und berechne die Summe \\(1 + \\cdots + n\\) mit <code>for</code>.  Gib Ergebnis in einem Label aus.</p> Tipp <p>Rechenbeispiele:</p> <p>\\(1+2+3+ \\cdots +10=55\\)</p> <p>\\(1+2+3+ \\cdots +100=5050\\)</p> <p>\\(1+2+3+ \\cdots +300=45150\\)</p> <p>\\(1+2+3+ \\cdots +1000=500500\\)</p> <p>Vorgehen:</p> <p>Erstelle eine Variable <code>sum = 0;</code>, in der die einzelnen Summanden addiert werden.</p> L\u00f6sung <pre><code>int n = (int)NumN.Value;\n\nint sum = 0;\n\nfor (int i = 1; i &lt;= n; i++)\n{\n    sum = sum + i;\n}\n\nLblAnzeige.Text = $\"Summe 1..{n} = {sum}\";\n</code></pre> <p>Man kann auch statt <code>sum = sum + i;</code> auch k\u00fcrzer <code>sum += i;</code> schreiben.</p> for \u2013 Produkt 1..n <p>Nutze ein NumericUpDown, um eine Zahl <code>n</code> auszulesen und berechne das Produkt \\(1 \\cdot 2 \\cdot \\cdots \\cdot n\\) mit <code>for</code>. </p> <p>Gib Ergebnis in einem Label aus.</p> <p>Diese Produkte sind in der Stochastik sehr wichtig und es wird \\(n!\\) f\u00fcr \\(1 \\cdot 2 \\cdot \\cdots \\cdot n\\)  geschrieben. \\(n!\\) liest man als \"\\(n\\) Fakult\u00e4t\".</p> <p>Wenn <code>n</code> zu gro\u00df wird, dann wird \\(n!\\) nicht mehr korrekt berechnet. Bei welchen <code>n</code> passiert das zum ersten mal und warum? Wie h\u00e4ngt das mit dem gew\u00e4hlten Datentypen zusammen?</p> Tipp <p>Rechenbeispiele:</p> <p>\\(1! = 1\\)</p> <p>\\(2! = 1 \\cdot 2 = 2\\)</p> <p>\\(3! = 1 \\cdot 2 \\cdot 3 = 6\\)</p> <p>\\(4! = 1 \\cdot 2 \\cdot 3 \\cdot 4 = 24\\)</p> <p>\\(5! = 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5= 120\\)</p> <p>\\(10! = 1 \\cdot 2 \\cdot 3 \\cdot  \\cdots \\cdot 10=3628800\\)</p> <p>\\(20! = 1 \\cdot 2 \\cdot 3 \\cdot  \\cdots \\cdot 20=2432902008176640000\\)</p> <p>Vorgehen:</p> <p>Erstelle eine Variable <code>prod = 1;</code>, in der die einzelnen Summanden addiert werden.</p> L\u00f6sung <pre><code>int n = (int)NumN.Value;\n\nint prod = 1;\n\nfor (int i = 1; i &lt;= n; i++)\n{\n    prod = prod * i;\n}\n\nLblAnzeige.Text = $\"{n}! = {prod}\";\n</code></pre> <p>Man kann auch statt <code>prod = prod * i;</code> auch k\u00fcrzer <code>prod *= i;</code> schreiben.</p> <p>Ab wann wird's falsch?</p> <p><code>int</code> (32 Bit, MaxValue 2_147_483_647): korrekt bis 12!, bei 13! \u00dcberlauf.</p> <p><code>long</code> (64 Bit, MaxValue 9_223_372_036_854_775_807): korrekt bis 20!, bei 21! \u00dcberlauf.</p> <p><code>decimal</code> (128 Bit, \u2248 7.9 \u00d7 10^28): exakt bis 27!, 28! ist zu gro\u00df.</p> <p><code>double</code> (Gleitkomma): numerischer \u00dcberlauf erst ab 171!, aber exakte Ganzzahlgenauigkeit geht bereits ab 19! verloren (weil double ganze Zahlen nur bis 2^53 \u2248 9e15 exakt darstellen kann).</p> <p>Warum passiert das?</p> <p>Die Fakult\u00e4t w\u00e4chst extrem schnell. Jeder Datentyp hat einen Maximalwert. Wird dieser \u00fcberschritten, kommt es zum \u00dcberlauf.</p> <p>Alternativ l\u00e4sst sich die Klasse <code>BigInteger</code> verwenden:</p> <pre><code>using System.Numerics;\n\nint n = (int)NumN.Value;\nBigInteger prod = BigInteger.One;\n\nfor (int i = 1; i &lt;= n; i++)\n    prod *= i;\n\nLblAnzeige.Text = $\"{n}! = {prod}\";\n</code></pre> Weiter Aufgaben im Buch <p>Im Buch liegen noch im Abschnitt 2.7.3 insgesamt vier gute \u00dcbungsaufgaben vor:</p> <ul> <li>USchleifeFor</li> <li>USchleifeWhile</li> <li>UZahlenraten</li> <li>USteuertabelle</li> </ul>"},{"location":"content/2_8/","title":"2.8 Schleifen und Steuerelemente","text":"ListBox f\u00fcllen (1..n) <p>F\u00fclle eine <code>ListBox</code> (<code>LstZahlen</code>) mit den Zahlen 1 bis 10 per <code>for</code>. W\u00e4hle dann die 7 aus.</p> Tipp <p>F\u00fcge den Code in <code>Form1_Load(...)</code> hinzu.</p> L\u00f6sung <pre><code>public Form1()\n{\n    InitializeComponent();\n\n    LstZahlen.Items.Clear();\n    for (int i = 1; i &lt;= 10; i++) LstZahlen.Items.Add(i);\n    LstZahlen.SelectedItem = 7;\n}\n</code></pre> Summe bilden <p>Erstelle eine ListBox, eine TextBox und einen Button. Immer wenn auf den Button geklickt wird, wird die Zahl, die in der TextBox steht, in die ListBox eingetragen. F\u00fcge ein Label hinzu, dass die Summe der Elemente in der Listbox zeigt.</p> Tipp <p>Die Elemente in der Textbox sind <code>string</code>. Wenn du sie also aufsummieren willst, musst du sie vorher einen passenden Datentypen verwandeln.</p> L\u00f6sung <pre><code>// Button-Click-Handler: Zahl aus TextBox eintragen und Summe aktualisieren\nprivate void BtnAdd_Click(object sender, EventArgs e)\n{\n    // Theoretisch m\u00fcsste man hier pr\u00fcfen, dass es sich bei der Eingabe\n    // tats\u00e4chlich um eine Zahl handelt. Dies \u00fcberspringen wir hier aber.\n    LstZahlen.Items.Add(value);\n    UpdateSumme();\n    TxtZahl.Clear();\n\n}\n\n// Hilfsmethode: Summe der ListBox-Elemente berechnen und im Label anzeigen\nprivate void UpdateSumme()\n{\n    int sum = 0;\n    foreach (var item in LstZahlen.Items)\n        sum += Convert.ToInt32(item);\n\n    LblSumme.Text = $\"Summe: {sum}\";\n}\n\n// Optional: beim Laden initialisieren\nprivate void Form1_Load(object sender, EventArgs e)\n{\n    InitializeComponent();\n\n    LstZahlen.Items.Clear();\n    UpdateSumme(); // zeigt \"Summe: 0\"\n}\n</code></pre> Todo-App <p>Erstelle mit deinen Bisherigen Mitteln eine Anwendung, um eine Todo-Liste zu zu erstellen. In einer ListBox sollen die Elemente aufgelistet sein. Es soll m\u00f6glich sein neue Elemente hinzuzuf\u00fcgen und bestehende zu l\u00f6schen.</p> L\u00f6sung <p>Die folgende L\u00f6sung wurde mit ChatGPT erstellt und enth\u00e4lt ein paar Funktionen, die \u00fcber unsere Mittel hinausgehen. Diese sind aber verst\u00e4ndlich oder gut kommentiert. Da wir hier also weitere Funktionen lernen k\u00f6nnen, lasse ich es als L\u00f6sung.</p> <pre><code>// F\u00fcgt ein neues Todo aus der TextBox hinzu\nprivate void BtnAdd_Click(object sender, EventArgs e)\n{\n    var text = TxtTodo.Text.Trim();\n    if (string.IsNullOrEmpty(text))\n    {\n        MessageBox.Show(\"Bitte einen Text eingeben.\");\n        TxtTodo.Focus();\n        return;\n    }\n\n    LstTodos.Items.Add(text);\n    TxtTodo.Clear();\n    TxtTodo.Focus();\n}\n\n// L\u00f6scht ausgew\u00e4hlte Todo(s) aus der ListBox\nprivate void BtnDelete_Click(object sender, EventArgs e)\n{\n    if (LstTodos.SelectedIndices.Count == 0)\n    {\n        MessageBox.Show(\"Bitte mindestens ein Element ausw\u00e4hlen.\");\n        return; // Die Methode wird vorzeitig beendet.\n    }\n\n    // Von hinten l\u00f6schen, damit Indizes g\u00fcltig bleiben\n    for (int i = LstTodos.SelectedIndices.Count - 1; i &gt;= 0; i--)\n    {\n        LstTodos.Items.RemoveAt(LstTodos.SelectedIndices[i]);\n    }\n}\n\n// Optional: Initialisieren und Mehrfachauswahl erlauben\nprivate void Form1_Load(object sender, EventArgs e)\n{\n    LstTodos.Items.Clear();\n    LstTodos.SelectionMode = SelectionMode.MultiExtended; // Mehrfachauswahl zum L\u00f6schen\n}\n\n// Optional: Enter f\u00fcgt hinzu, Entf l\u00f6scht\nprivate void TxtTodo_KeyDown(object sender, KeyEventArgs e)\n{\n    if (e.KeyCode == Keys.Enter)\n    {\n        e.SuppressKeyPress = true;\n        BtnAdd.PerformClick();\n    }\n}\n\nprivate void LstTodos_KeyDown(object sender, KeyEventArgs e)\n{\n    if (e.KeyCode == Keys.Delete)\n    {\n        BtnDelete.PerformClick();\n    }\n}\n</code></pre> UListBox <p>Im Buch auf Seite 123 befindet sich die Aufgabe UListBox, die Sie gerne l\u00f6sen k\u00f6nnen.</p> Umst\u00e4ndlicher Safe <p>Erstelle vier ComboBoxen, jeweils mit den Zahlen von 0 bis 9.</p> <p>Speichere in einer Konstanten <code>passwort</code> einen String aus 4 Ziffern.</p> <p>Erstelle einen Button \"Pr\u00fcfe Code\". Wenn dieser geklickt wird, werden die ausgew\u00e4hlten Ziffern der 4 ComboBoxen zu einem String zusammengesetzt und mit dem <code>passwort</code> verglichen. Wenn die Strings nicht \u00fcbereinstimmen, erscheint in rot der Text \"Falsches Passwort\". Wenn sie \u00fcbereinstimmen, erscheint ein Text mit einem Geheimnis von dir.</p> <p>Bonus: Beende das Programm, wenn drei Mal das falsche Passwort ausgew\u00e4hlt wurde.</p> L\u00f6sung <pre><code>// Konstante f\u00fcr das Passwort und Z\u00e4hler f\u00fcr Fehlversuche\nprivate const string passwort = \"1234\"; // 4-stellig\nprivate int fehlversuche = 0;\n\n// Beim Laden: ComboBoxen mit 0..9 f\u00fcllen und initial ausw\u00e4hlen\nprivate void Form1_Load(object sender, EventArgs e)\n{\n    // Ohne Arrays: jede ComboBox einzeln f\u00fcllen\n    Cmb1.Items.Clear();\n    for (int i = 0; i &lt;= 9; i++)\n    {\n        Cmb1.Items.Add(i);\n        Cmb2.Items.Add(i);\n        Cmb3.Items.Add(i);\n        Cmb4.Items.Add(i);\n    }\n\n    LblStatus.Text = string.Empty;\n}\n\n// Button-Handler: Code pr\u00fcfen\nprivate void BtnPruefe_Click(object sender, EventArgs e)\n{\n    string code = ($\"{Cmb1.SelectedItem}{Cmb2.SelectedItem}{Cmb3.SelectedItem}{Cmb4.SelectedItem}\");\n\n    if (code == passwort)\n    {\n        LblStatus.ForeColor = Color.Green;\n        LblStatus.Text = \"Geheimnis: Ich habe ein s\u00fc\u00dfes Gummienten-Maskottchen auf dem Schreibtisch.\";\n\n        // Optional: Nach Erfolg Eingaben deaktivieren\n        Cmb1.Enabled = Cmb2.Enabled = Cmb3.Enabled = Cmb4.Enabled = false;\n        BtnPruefe.Enabled = false;\n        return;\n    }\n\n    // Falsches Passwort\n    fehlversuche++;\n    LblStatus.ForeColor = Color.Red;\n    LblStatus.Text = \"Falsches Passwort\";\n\n    if (fehlversuche &gt;= 3)\n    {\n        Application.Exit(); // Bonus: nach 3 Fehlversuchen beenden\n    }\n}\n</code></pre>"},{"location":"content/3/","title":"3 Fehlerbehandlung &amp; Debugging","text":"try/catch \u2013 Division mit Validierung <p>Erstelle zwei Eingabefelder (z.\u202fB. <code>TxtA</code>, <code>TxtB</code>) und einen Button <code>CmdDiv</code>, der <code>A / B</code> berechnet. Validierte Eingaben vermeiden Abst\u00fcrze und melden Fehler nutzerfreundlich.</p> <p>Anforderungen</p> <ul> <li>Versuche, <code>double.Parse</code> zu verwenden und fange Formatfehler in <code>catch (FormatException)</code>.</li> <li>Pr\u00fcfe auf Division durch 0 und wirf in diesem Fall gezielt eine <code>DivideByZeroException</code>, die du ebenfalls f\u00e4ngst.</li> <li>Zeige das Ergebnis bzw. die Fehlermeldung in einer <code>MessageBox</code> an.</li> </ul> L\u00f6sung <pre><code>private void CmdDiv_Click(object sender, EventArgs e)\n{\n    try\n    {\n        double a = double.Parse(TxtA.Text);\n        double b = double.Parse(TxtB.Text);\n\n        if (b == 0)\n            throw new DivideByZeroException(\"Division durch 0 ist nicht erlaubt.\");\n\n        double res = a / b;\n        MessageBox.Show($\"Ergebnis: {res}\", \"Division\");\n    }\n    catch (FormatException)\n    {\n        MessageBox.Show(\"Bitte g\u00fcltige Zahlen eingeben.\", \"Eingabefehler\");\n    }\n    catch (DivideByZeroException ex)\n    {\n        MessageBox.Show(ex.Message, \"Rechenfehler\");\n    }\n    catch (Exception ex)\n    {\n        MessageBox.Show($\"Unerwarteter Fehler: {ex.Message}\", \"Fehler\");\n    }\n}\n</code></pre> TryParse statt Ausnahme \u2013 robuste Umwandlung <p>Erweitere die Division aus Aufgabe 03_00_01 so, dass keine Ausnahmen beim Parsen auftreten. Nutze <code>double.TryParse</code> und gib bei ung\u00fcltiger Eingabe eine klare Meldung aus.</p> <p>Hinweis</p> <ul> <li><code>TryParse</code> liefert <code>true/false</code> und schreibt bei Erfolg den konvertierten Wert in eine <code>out</code>\u2011Variable.</li> </ul> L\u00f6sung <pre><code>private void CmdDiv_Click(object sender, EventArgs e)\n{\n    if (!double.TryParse(TxtA.Text, out double a) ||\n        !double.TryParse(TxtB.Text, out double b))\n    {\n        MessageBox.Show(\"Bitte zwei g\u00fcltige Zahlen eingeben.\", \"Eingabefehler\");\n        return;\n    }\n\n    if (b == 0)\n    {\n        MessageBox.Show(\"Division durch 0 ist nicht erlaubt.\", \"Rechenfehler\");\n        return;\n    }\n\n    double res = a / b;\n    MessageBox.Show($\"Ergebnis: {res}\", \"Division\");\n}\n</code></pre> finally \u2013 Ressourcen bereinigen nach Dateioperation <p>Simuliere das \u00d6ffnen einer Datei mit <code>StreamReader</code>. Lies die erste Zeile und zeige sie, unabh\u00e4ngig von Fehlern, sauber an. Stelle sicher, dass der Reader im <code>finally</code> immer geschlossen wird.</p> <p>Akzeptanzkriterien</p> <ul> <li>Bei nicht vorhandener Datei erscheint eine verst\u00e4ndliche Fehlermeldung.</li> <li>Der Reader wird im <code>finally</code> geschlossen (auch bei Fehlern).</li> </ul> L\u00f6sung <pre><code>using System.IO;\n\nprivate void CmdReadFirstLine_Click(object sender, EventArgs e)\n{\n    StreamReader? sr = null;\n    try\n    {\n        sr = new StreamReader(\"data.txt\");\n        string? line = sr.ReadLine();\n        MessageBox.Show(line ?? \"(leer)\", \"Erste Zeile\");\n    }\n    catch (IOException ex)\n    {\n        MessageBox.Show($\"Dateifehler: {ex.Message}\", \"IO-Fehler\");\n    }\n    finally\n    {\n        sr?.Close();\n    }\n}\n</code></pre> Eigene Ausnahme \u2013 Gesch\u00e4ftsregel pr\u00fcfen <p>Implementiere eine kleine Gesch\u00e4ftsregel: Ein Alterswert muss zwischen 0 und 120 liegen. Bei Versto\u00df soll eine eigene Ausnahme <code>AgeOutOfRangeException</code> geworfen und gefangen werden.</p> <p>Schritte</p> <ul> <li>Definiere eine Klasse <code>AgeOutOfRangeException : Exception</code> mit passendem Konstruktor.</li> <li>Schreibe eine Methode <code>ValidateAge(int age)</code>, die bei ung\u00fcltigem Bereich die Ausnahme wirft.</li> <li>Fange die Ausnahme beim Klicken eines Buttons und zeige eine klare Meldung.</li> </ul> L\u00f6sung <pre><code>public class AgeOutOfRangeException : Exception\n{\n    public AgeOutOfRangeException(string message) : base(message) {}\n}\n\nprivate void ValidateAge(int age)\n{\n    if (age &lt; 0 || age &gt; 120)\n        throw new AgeOutOfRangeException($\"Alter {age} ist au\u00dferhalb des erlaubten Bereichs.\");\n}\n\nprivate void CmdCheckAge_Click(object sender, EventArgs e)\n{\n    int age = (int)NumAge.Value;\n    try\n    {\n        ValidateAge(age);\n        MessageBox.Show(\"Alter ist g\u00fcltig.\");\n    }\n    catch (AgeOutOfRangeException ex)\n    {\n        MessageBox.Show(ex.Message, \"Validierungsfehler\");\n    }\n}\n</code></pre> Debugging \u2013 Breakpoints &amp; Watch (Anleitung) <p>\u00dcbe Debugging in Visual Studio anhand einer kleinen Methode <code>SumUntil(n)</code>, die 1+\u2026+n summiert. Setze Breakpoints und beobachte Variablen im Watch\u2011Fenster.</p> <p>Vorgehen</p> <ul> <li>Erstelle <code>int SumUntil(int n)</code> mit einer <code>for</code>\u2011Schleife.</li> <li>Setze einen Breakpoint auf die Zeile, die die Summe addiert.</li> <li>Starte im Debug\u2011Modus (F5), l\u00f6se die Methode \u00fcber einen Button aus und steuere mit F10/F11.</li> <li>\u00d6ffne das Watch\u2011Fenster und beobachte <code>i</code> und <code>sum</code>.</li> </ul> L\u00f6sung <pre><code>private int SumUntil(int n)\n{\n    int sum = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        sum += i; // Breakpoint hier setzen und i/sum beobachten\n    }\n    return sum;\n}\n\nprivate void CmdSum_Click(object sender, EventArgs e)\n{\n    int n = (int)NumN.Value;\n    LblAnzeige.Text = SumUntil(n).ToString();\n}\n</code></pre>"},{"location":"content/4/","title":"4 Erweiterte Grundlagen","text":"Methoden \u2013 Signatur, R\u00fcckgabe, benannte/optionale Parameter <p>Implementiere eine Methode <code>PreisMitSteuer(decimal netto, decimal steuersatz = 0.19m)</code>, die den Bruttopreis zur\u00fcckgibt. Rufe sie mit benannten Parametern auf und zeige die Ausgabe formatiert.</p> <p>Beispiel</p> <ul> <li><code>PreisMitSteuer(netto: 59.90m)</code></li> <li><code>PreisMitSteuer(netto: 59.90m, steuersatz: 0.07m)</code></li> </ul> L\u00f6sung <pre><code>private decimal PreisMitSteuer(decimal netto, decimal steuersatz = 0.19m)\n{\n    return netto * (1 + steuersatz);\n}\n\nprivate void CmdTest_Click(object sender, EventArgs e)\n{\n    decimal a = PreisMitSteuer(netto: 59.90m);\n    decimal b = PreisMitSteuer(netto: 59.90m, steuersatz: 0.07m);\n    LblAnzeige.Text = $\"19%: {a:F2} \u20ac\\n7%:  {b:F2} \u20ac\";\n}\n</code></pre> ref/out \u2013 Tauschen und Parsen <p>Schreibe zwei kleine Helfer:</p> <ul> <li><code>void Swap(ref int a, ref int b)</code> vertauscht zwei Werte.</li> <li><code>bool TryReadInt(string s, out int value)</code> liefert <code>true</code>, wenn <code>s</code> eine Ganzzahl ist.</li> </ul> <p>Teste beides in einem Button\u2011Klick und zeige die Ergebnisse.</p> L\u00f6sung <pre><code>private void Swap(ref int a, ref int b) { (a, b) = (b, a); }\n\nprivate bool TryReadInt(string s, out int value)\n{\n    return int.TryParse(s, out value);\n}\n\nprivate void CmdTest_Click(object sender, EventArgs e)\n{\n    int x = 3, y = 7;\n    Swap(ref x, ref y);\n\n    bool ok = TryReadInt(TxtEingabe.Text, out int v);\n    LblAnzeige.Text = $\"Swap: x={x}, y={y}\\nParse: ok={ok}, v={v}\";\n}\n</code></pre> Rekursion \u2013 Fakult\u00e4t und Fibonacci (kleine n) <p>Implementiere zwei rekursive Methoden mit kleiner <code>n</code>\u2011Begrenzung:</p> <ul> <li><code>long Fak(int n)</code> mit <code>Fak(0) = 1</code>.</li> <li><code>long Fib(int n)</code> mit <code>Fib(0)=0</code>, <code>Fib(1)=1</code>.</li> </ul> <p>Zeige beide Werte f\u00fcr <code>n</code> aus einem <code>NumericUpDown</code> an und warne f\u00fcr zu gro\u00dfes <code>n</code>.</p> L\u00f6sung <pre><code>private long Fak(int n) =&gt; n &lt;= 1 ? 1 : n * Fak(n - 1);\n\nprivate long Fib(int n) =&gt; n &lt;= 1 ? n : Fib(n - 1) + Fib(n - 2);\n\nprivate void CmdCalc_Click(object sender, EventArgs e)\n{\n    int n = (int)NumN.Value; // z. B. Max 20\n    if (n &gt; 20)\n    {\n        MessageBox.Show(\"Bitte n \u2264 20 w\u00e4hlen.\", \"Warnung\");\n        return;\n    }\n    LblAnzeige.Text = $\"Fak({n}) = {Fak(n)}\\nFib({n}) = {Fib(n)}\";\n}\n</code></pre> Arrays \u2013 Minimum, Maximum, Durchschnitt <p>Lies eine kommaseparierte Liste von Ganzzahlen aus <code>TxtListe</code> ein und berechne auf einem <code>int[]</code>:</p> <ul> <li>Minimum und Maximum</li> <li>Summe und Durchschnitt (auf zwei Nachkommastellen)</li> </ul> <p>Zeige die Ergebnisse mehrzeilig an.</p> L\u00f6sung <pre><code>private void CmdStats_Click(object sender, EventArgs e)\n{\n    var parts = TxtListe.Text.Split(',', StringSplitOptions.RemoveEmptyEntries);\n    var arr = parts.Select(p =&gt; int.Parse(p.Trim())).ToArray();\n\n    int min = arr.Min();\n    int max = arr.Max();\n    int sum = arr.Sum();\n    double avg = arr.Average();\n\n    LblAnzeige.Text = $\"Min: {min}\\nMax: {max}\\nSumme: {sum}\\n\u00d8: {avg:F2}\";\n}\n</code></pre> Jagged Array \u2013 Tabellenf\u00f6rmig anzeigen <p>Erzeuge ein gezacktes Array <code>int[][]</code>, z.\u202fB. drei Zeilen mit unterschiedlicher L\u00e4nge, f\u00fclle es mit Zahlen und gib jede Zeile in einer neuen Label\u2011Zeile aus.</p> <p>Hinweis</p> <ul> <li>Verwende <code>string.Join(\" \", zeile)</code> zum Formatieren.</li> </ul> L\u00f6sung <pre><code>private void CmdJagged_Click(object sender, EventArgs e)\n{\n    int[][] a =\n    {\n        new[] {1, 2, 3},\n        new[] {4, 5},\n        new[] {6, 7, 8, 9}\n    };\n\n    var lines = a.Select(row =&gt; string.Join(\" \", row));\n    LblAnzeige.Text = string.Join(\"\\n\", lines);\n}\n</code></pre> Nullable und Null\u2011Koaleszenz <p>Verwende <code>int?</code> f\u00fcr eine optionale Eingabe. Zeige den Wert an oder ersatzweise <code>0</code>, wenn <code>null</code>. Nutze dazu den Null\u2011Koaleszenz\u2011Operator <code>??</code>.</p> <p>Beispiel</p> <ul> <li><code>int? vielleicht = null;</code></li> <li><code>int sicher = vielleicht ?? 0;</code></li> </ul> L\u00f6sung <pre><code>private void CmdNullables_Click(object sender, EventArgs e)\n{\n    int? vielleicht = string.IsNullOrWhiteSpace(TxtEingabe.Text) ? null : int.Parse(TxtEingabe.Text);\n    int sicher = vielleicht ?? 0;\n    LblAnzeige.Text = $\"Eingabe: {(vielleicht.HasValue ? vielleicht.Value.ToString() : \"null\")}\\nErsatz: {sicher}\";\n}\n</code></pre> Tupel \u2013 Mehrfachr\u00fcckgabe <p>Schreibe <code>static (int min, int max, double avg) Analyse(int[] a)</code>, die Minimum, Maximum und Durchschnitt eines Arrays liefert. Demonstriere den Aufruf mit Dekonstruktion.</p> L\u00f6sung <pre><code>private static (int min, int max, double avg) Analyse(int[] a)\n{\n    return (a.Min(), a.Max(), a.Average());\n}\n\nprivate void CmdAnalyse_Click(object sender, EventArgs e)\n{\n    int[] a = { 5, 1, 9, 3 };\n    var (mi, ma, av) = Analyse(a);\n    LblAnzeige.Text = $\"Min: {mi}\\nMax: {ma}\\n\u00d8: {av:F2}\";\n}\n</code></pre> Methoden\u00fcberladung \u2013 Drei Varianten <code>Area</code> <p>\u00dcberlade eine Methode <code>Area(...)</code> f\u00fcr</p> <ul> <li>Quadrat (<code>side</code>)</li> <li>Rechteck (<code>width</code>, <code>height</code>)</li> <li>Kreis (<code>radius</code>)</li> </ul> <p>und zeige jeweils die berechnete Fl\u00e4che.</p> L\u00f6sung <pre><code>private double Area(double side) =&gt; side * side;\nprivate double Area(double width, double height) =&gt; width * height;\nprivate double AreaCircle(double radius) =&gt; Math.PI * radius * radius;\n\nprivate void CmdArea_Click(object sender, EventArgs e)\n{\n    double a = Area(3);\n    double b = Area(4, 2);\n    double c = AreaCircle(2.5);\n    LblAnzeige.Text = $\"Quadrat: {a:F2}\\nRechteck: {b:F2}\\nKreis: {c:F2}\";\n}\n</code></pre>"},{"location":"content/4_5/","title":"4.5 Methoden","text":"Links oder rechts groesser? <p>Erstelle zwei NumericUpDowns (<code>NumLinks</code>, <code>NumRechts</code>) und ein Label (<code>LblVergleich</code>). Das Label soll anzeigen, ob der linke oder rechte Wert groesser ist oder ob beide gleich gross sind.</p> <p>Lagere die Beschriftung in eine Methode <code>UpdateVergleich()</code> aus und rufe diese in den <code>ValueChanged</code>-Handlern beider NumericUpDowns auf.</p> L\u00f6sung <p>Erwartete Steuerelemente (Beispielnamen):</p> <ul> <li><code>NumLinks</code>, <code>NumRechts</code> (NumericUpDown)</li> <li><code>LblVergleich</code> (Label)</li> </ul> <pre><code>// Aktualisiert die Anzeige im Label basierend auf den beiden Werten\nprivate void UpdateVergleich()\n{\n    decimal links = NumLinks.Value;\n    decimal rechts = NumRechts.Value;\n\n    if (links &gt; rechts)\n        LblVergleich.Text = \"links groesser\";\n    else if (rechts &gt; links)\n        LblVergleich.Text = \"rechts groesser\";\n    else\n        LblVergleich.Text = \"gleich gross\";\n}\n\n// Beide NumericUpDowns rufen dieselbe Methode auf\nprivate void NumLinks_ValueChanged(object sender, EventArgs e)\n{\n    UpdateVergleich();\n}\n\nprivate void NumRechts_ValueChanged(object sender, EventArgs e)\n{\n    UpdateVergleich();\n}\n\n// Optional: initial setzen (z.B. im Form-Load)\nprivate void Form1_Load(object sender, EventArgs e)\n{\n    UpdateVergleich();\n}\n</code></pre> Immer mehr x... <p>Erstelle zwei Buttons und ein Label.</p> <p>Immer wenn auf einer der Buttons geklickt wird, soll auf dem Label ein weiters <code>x</code>  erscheinen.</p> <p>Implementiere das, indem beide Buttons eine Funktion <code>add_letter_x</code> verwenden.</p> L\u00f6sung <p>Erwartete Steuerelemente (Beispielnamen):</p> <ul> <li><code>CmdA</code>, <code>CmdB</code> (Buttons)</li> <li><code>LblText</code> (Label)</li> </ul> <pre><code>// Gemeinsame Funktion, die ein \"x\" anh\u00e4ngt\nprivate void add_letter_x()\n{\n    LblText.Text += \"x\";\n}\n\n// Beide Buttons rufen dieselbe Funktion auf\nprivate void CmdA_Click(object sender, EventArgs e)\n{\n    add_letter_x();\n}\n\nprivate void CmdB_Click(object sender, EventArgs e)\n{\n    add_letter_x();\n}\n</code></pre> x und y und beliebig <p>Erstelle zwei Buttons und ein Label.</p> <p>Immer wenn auf einer der Buttons geklickt wird, soll auf dem Label ein weiters <code>x</code>  erscheinen.</p> <p>Implementiere das, indem beide Buttons eine Funktion <code>add_letter(string text)</code> verwenden.</p> <p>\ud83d\ude80Bonus: F\u00fcge einen wetieren Button und eine Textbox ein. Wenn der dritte Button gedr\u00fcckt wird, so soll der Text aus der Textbox dem Label hinzugef\u00fcgt werden.</p> L\u00f6sung <p>Erwartete Steuerelemente (Beispielnamen):</p> <ul> <li><code>CmdA</code>, <code>CmdB</code> (Buttons)</li> <li><code>LblText</code> (Label)</li> </ul> <pre><code>// Gemeinsame Funktion, die ein \"x\" anh\u00e4ngt\nprivate void add_letter(string text)\n{\n    LblText.Text += text;\n}\n\n// Beide Buttons rufen dieselbe Funktion auf\nprivate void CmdA_Click(object sender, EventArgs e)\n{\n    add_letter(\"x\");\n}\n\nprivate void CmdB_Click(object sender, EventArgs e)\n{\n    add_letter_x(\"y\");\n}\n</code></pre> <p>\ud83d\ude80Bonus</p> <p>Erwartete Steuerelemente (Beispielnamen):</p> <ul> <li><code>CmdC</code> (Button)</li> <li><code>TxtEingabe</code> (Textbox)</li> </ul> <pre><code>private void CmdC_Click(object sender, EventArgs e)\n{\n    add_letter_x(TxtEingabe.Text);\n}\n</code></pre> Der Countdown laeuft <p>Erstelle drei Buttons mit den Texten \"30\", \"10\", \"3\" und ein Label.</p> <p>Wenn auf den Button geklickt wird, soll man auf dem Label einen Countdown sehen. Beim Button \"30\" zaehlt er von 30 bis 0 herunter, beim \"10\" von 10 bis 0 usw.</p> <p>Nutze einen Timer, um den Countdown darzustellen.</p> <p>Ueberlege, an welcher Stelle ein Timer sinnvoll eingesetzt werden kann.</p> <p>\ud83d\ude80Bonus</p> <ul> <li>Wie laesst sich einstellen, dass die Buttons nicht geklickt werden koennen, wenn der Countdown laeuft?</li> <li>Wie laesst sich ueber RadioButtons die Geschwindigkeit der Countdowns einstellen? (z.B. schnell fuer 100 ms und langsam fuer 1000 ms)</li> </ul> L\u00f6sung <p>Erwartete Steuerelemente (Beispielnamen):</p> <ul> <li><code>Cmd30</code>, <code>Cmd10</code>, <code>Cmd3</code> (Buttons)</li> <li><code>LblCountdown</code> (Label)</li> <li><code>TmrCountdown</code> (Timer)</li> </ul> <p>Grundloesung (einfach)</p> <pre><code>// Einfache Loesung: 1 Timer, 1 Zaehler\nprivate int remaining = 0;\n\n// Kleine Hilfsfunktion: Anzeige aktualisieren\nprivate void UpdateCountdownLabel()\n{\n    LblCountdown.Text = $\"{remaining}\";\n}\n\nprivate void StartCountdown(int seconds)\n{\n    remaining = seconds;\n    UpdateCountdownLabel();\n\n    TmrCountdown.Interval = 1000; // 1 Sekunde\n    TmrCountdown.Start();\n}\n\nprivate void TmrCountdown_Tick(object sender, EventArgs e)\n{\n    remaining--;\n    UpdateCountdownLabel();\n\n    if (remaining &lt;= 0)\n    {\n        TmrCountdown.Stop();\n    }\n}\n\n// Button-Click-Handler\nprivate void Cmd30_Click(object sender, EventArgs e)\n{\n    StartCountdown(30);\n}\n\nprivate void Cmd10_Click(object sender, EventArgs e)\n{\n    StartCountdown(10);\n}\n\nprivate void Cmd3_Click(object sender, EventArgs e)\n{\n    StartCountdown(3);\n}\n</code></pre> <p>Bonus: Buttons sperren und Geschwindigkeit waehlen</p> <p>Zusaetzliche Steuerelemente (Beispielnamen):</p> <ul> <li><code>RbSchnell</code>, <code>RbLangsam</code> (RadioButtons)</li> </ul> <pre><code>// Buttons waehrend des Countdowns sperren\nprivate void SetButtonsEnabled(bool enabled)\n{\n    Cmd30.Enabled = enabled;\n    Cmd10.Enabled = enabled;\n    Cmd3.Enabled  = enabled;\n}\n\n// Geschwindigkeit vor dem Start setzen\nprivate void SetSpeed()\n{\n    if (RbSchnell.Checked)\n        TmrCountdown.Interval = 100;   // schnell\n    else if (RbLangsam.Checked)\n        TmrCountdown.Interval = 1000;  // langsam\n    else\n        TmrCountdown.Interval = 500;   // Standard\n}\n\n// Kleine Hilfsfunktion: Anzeige aktualisieren\nprivate void UpdateCountdownLabel()\n{\n    LblCountdown.Text = $\"{remaining}\";\n}\n\n// Angepasster Start mit Bonus (ersetzt die einfache StartCountdown-Methode)\nprivate void StartCountdown(int seconds)\n{\n    remaining = seconds;\n    UpdateCountdownLabel();\n\n    SetSpeed();           // Geschwindigkeit waehlen\n    SetButtonsEnabled(false);\n    TmrCountdown.Start();\n}\n\nprivate void TmrCountdown_Tick(object sender, EventArgs e)\n{\n    remaining--;\n    UpdateCountdownLabel();\n\n    if (remaining &lt;= 0)\n    {\n        TmrCountdown.Stop();\n        SetButtonsEnabled(true);\n    }\n}\n</code></pre> Mehrwertsteuer berechnen <p>Erstellen Sie eine Form mit einem Eingabefeld f\u00fcr Zahlen. In dieses soll ein  Nettobetrag eingetragen werden.</p> <p>Erstellen sie daneben 3 Radiobuttons mit (19%, 7%, 0%), der den Steuersatz der Mehrwertsteuer angibt.</p> <p>Erstellen Sie zwei Labels. Im ersten Label soll die Mehrwertsteuer berechnet und ausgegeben werden und in der zweiten die soll der Bruttobetrag angezeigt werden.</p> <p>Erstelle eine Funktion, die die Steuerlast berechnet.</p> L\u00f6sung <p>Erwartete Steuerelemente (Beispielnamen): - <code>NumNetto</code> (NumericUpDown), <code>Rb19</code>, <code>Rb7</code>, <code>Rb0</code> (RadioButtons), - <code>LblMwst</code>, <code>LblBrutto</code> (Labels)</p> <pre><code>private decimal Steuer()\n{\n    decimal netto = NumNetto.Value; // Eingabefeld (NumericUpDown)\n\n    decimal satz;\n    if (Rb19.Checked)\n        satz = 0.19m;\n    else if (Rb7.Checked)\n        satz = 0.07m;\n    else\n        satz = 0.00m; // 0%\n\n    return netto * satz;\n}\n\n// Stelle ein, dass Radiobuttons und NumericUpDown diese Funktion verwenden.\nprivate labelAktualisieren(object sender, EventArgs e){\n    LblMwst.Text   = $\"MwSt:   {Steuer()} \u20ac\";\n    LblBrutto.Text = $\"Brutto: {netto + Steuer()} \u20ac\";\n}\n</code></pre>"},{"location":"content/5/","title":"5 Objektorientierung (OOP)","text":"Klasse <code>Person</code> \u2013 Eigenschaften, Konstruktor, ToString <p>Implementiere eine Klasse <code>Person</code> mit</p> <ul> <li>auto\u2011Properties <code>Name</code> (string) und <code>Geburtsjahr</code> (int)</li> <li>Konstruktor <code>(string name, int jahr)</code></li> <li><code>override string ToString()</code> \u2192 <code>\"Name (Jahr)\"</code></li> </ul> <p>Erzeuge in der UI zwei Personen und gib sie jeweils aus.</p> L\u00f6sung <pre><code>public class Person\n{\n    public string Name { get; set; }\n    public int Geburtsjahr { get; set; }\n\n    public Person(string name, int jahr)\n    {\n        Name = name;\n        Geburtsjahr = jahr;\n    }\n\n    public override string ToString() =&gt; $\"{Name} ({Geburtsjahr})\";\n}\n\nprivate void CmdPerson_Click(object sender, EventArgs e)\n{\n    var p1 = new Person(\"Alex\", 1990);\n    var p2 = new Person(\"Sam\", 1985);\n    LblAnzeige.Text = $\"{p1}\\n{p2}\";\n}\n</code></pre> Equals/GetHashCode \u2013 Personen vergleichen <p>Erweitere <code>Person</code>, sodass zwei Personen als gleich gelten, wenn Name und Geburtsjahr \u00fcbereinstimmen. \u00dcberschreibe <code>Equals</code> und <code>GetHashCode</code> passend und demonstriere den Vergleich.</p> L\u00f6sung <pre><code>public class Person\n{\n    public string Name { get; set; }\n    public int Geburtsjahr { get; set; }\n\n    public Person(string name, int jahr) { Name = name; Geburtsjahr = jahr; }\n\n    public override string ToString() =&gt; $\"{Name} ({Geburtsjahr})\";\n\n    public override bool Equals(object? obj)\n    {\n        return obj is Person p &amp;&amp; p.Name == Name &amp;&amp; p.Geburtsjahr == Geburtsjahr;\n    }\n\n    public override int GetHashCode() =&gt; HashCode.Combine(Name, Geburtsjahr);\n}\n\nprivate void CmdEq_Click(object sender, EventArgs e)\n{\n    var a = new Person(\"Alex\", 1990);\n    var b = new Person(\"Alex\", 1990);\n    MessageBox.Show($\"a.Equals(b): {a.Equals(b)}\");\n}\n</code></pre> Vererbung \u2013 <code>Mitarbeiter : Person</code> mit <code>virtual/override</code> <p>Leite <code>Mitarbeiter</code> von <code>Person</code> ab und erg\u00e4nze eine Eigenschaft <code>Abteilung</code>. \u00dcberschreibe <code>ToString()</code> und rufe <code>base.ToString()</code> auf.</p> L\u00f6sung <pre><code>public class Mitarbeiter : Person\n{\n    public string Abteilung { get; set; }\n    public Mitarbeiter(string name, int jahr, string abteilung) : base(name, jahr)\n    {\n        Abteilung = abteilung;\n    }\n    public override string ToString() =&gt; base.ToString() + $\" \u2013 {Abteilung}\";\n}\n</code></pre> Abstrakte Klasse &amp; Polymorphie <p>Erstelle <code>abstract class Figur</code> mit <code>abstract double Flaeche()</code> und leite <code>Rechteck</code> und <code>Kreis</code> ab. Erzeuge beide und gib die Fl\u00e4chen \u00fcber eine gemeinsame <code>List&lt;Figur&gt;</code> aus.</p> L\u00f6sung <pre><code>public abstract class Figur\n{\n    public abstract double Flaeche();\n}\npublic class Rechteck : Figur\n{\n    public double W, H;\n    public Rechteck(double w, double h) { W = w; H = h; }\n    public override double Flaeche() =&gt; W * H;\n}\npublic class Kreis : Figur\n{\n    public double R;\n    public Kreis(double r) { R = r; }\n    public override double Flaeche() =&gt; Math.PI * R * R;\n}\n\nprivate void CmdFiguren_Click(object sender, EventArgs e)\n{\n    var list = new List&lt;Figur&gt; { new Rechteck(3,2), new Kreis(2.5) };\n    LblAnzeige.Text = string.Join(\"\\n\", list.Select(f =&gt; f.Flaeche().ToString(\"F2\")));\n}\n</code></pre> Interface \u2013 <code>ISpeicherbar</code> mit <code>Speichern()</code> <p>Definiere <code>interface ISpeicherbar { string Speichern(); }</code> und implementiere es in <code>Person</code>. Die Methode liefert eine CSV\u2011Zeile zur\u00fcck.</p> L\u00f6sung <pre><code>public interface ISpeicherbar { string Speichern(); }\n\npublic class Person : ISpeicherbar\n{\n    public string Name { get; set; }\n    public int Geburtsjahr { get; set; }\n    public Person(string n, int j) { Name = n; Geburtsjahr = j; }\n    public string Speichern() =&gt; $\"{Name};{Geburtsjahr}\";\n}\n</code></pre> Generics \u2013 <code>List&lt;Person&gt;</code> filtern &amp; sortieren <p>Lege eine <code>List&lt;Person&gt;</code> an, filtere alle mit Geburtsjahr \u2265 1990 und sortiere aufsteigend nach Name. Gib die Namen jeweils in einer neuen Zeile aus.</p> L\u00f6sung <pre><code>var list = new List&lt;Person&gt;\n{\n    new Person(\"Zoe\", 1980),\n    new Person(\"Alex\", 1992),\n    new Person(\"Mara\", 1995)\n};\n\nvar q = list.Where(p =&gt; p.Geburtsjahr &gt;= 1990)\n            .OrderBy(p =&gt; p.Name)\n            .Select(p =&gt; p.Name);\n\nLblAnzeige.Text = string.Join(\"\\n\", q);\n</code></pre> Record \u2013 Wertgleichheit demonstrieren <p>Definiere <code>public record Punkt(int X, int Y);</code> und zeige, dass zwei Punkte mit gleichen Werten als gleich gelten. Erkl\u00e4re kurz im Kommentar den Unterschied zu Referenzgleichheit.</p> L\u00f6sung <pre><code>public record Punkt(int X, int Y);\n\nprivate void CmdRecord_Click(object sender, EventArgs e)\n{\n    var a = new Punkt(1,2);\n    var b = new Punkt(1,2);\n    LblAnzeige.Text = $\"a==b: {a == b}\";\n}\n</code></pre> Operator\u00fcberladung \u2013 Vektor addieren <p>Erstelle einen <code>struct Vektor2D</code> mit <code>X</code>, <code>Y</code> und \u00fcberlade <code>+</code> zur komponentenweisen Addition. Demonstriere die Addition in der UI.</p> L\u00f6sung <pre><code>public struct Vektor2D\n{\n    public double X, Y;\n    public Vektor2D(double x, double y) { X = x; Y = y; }\n    public static Vektor2D operator +(Vektor2D a, Vektor2D b) =&gt; new Vektor2D(a.X + b.X, a.Y + b.Y);\n    public override string ToString() =&gt; $\"({X},{Y})\";\n}\n</code></pre> Extension Method \u2013 <code>IsEmail()</code> f\u00fcr <code>string</code> <p>Schreibe eine einfache Extension\u2010Methode <code>bool IsEmail(this string s)</code> (Basiskontrolle auf <code>@</code> und <code>.</code>) und teste sie mit Werten aus einer TextBox.</p> L\u00f6sung <pre><code>public static class StringExtensions\n{\n    public static bool IsEmail(this string s) =&gt; s.Contains(\"@\") &amp;&amp; s.Contains(\".\");\n}\n\nprivate void CmdCheck_Click(object sender, EventArgs e)\n{\n    LblAnzeige.Text = TxtEingabe.Text.IsEmail() ? \"OK\" : \"Nope\";\n}\n</code></pre> Delegates &amp; Events \u2013 Button\u2011Klick verkabeln <p>Lege einen eigenen <code>delegate void Log(string msg);</code> an und weise einer Variable eine Methode zu, die Meldungen in eine <code>ListBox</code> schreibt. Rufe den Delegate im Button\u2011Klick auf.</p> L\u00f6sung <pre><code>public delegate void Log(string msg);\n\nprivate void LogToList(string msg) =&gt; LstLog.Items.Add(msg);\n\nprivate void CmdDo_Click(object sender, EventArgs e)\n{\n    Log logger = LogToList;\n    logger($\"Clicked at {DateTime.Now}\");\n}\n</code></pre> Mehrere Formulare \u2013 Dialog f\u00fcr <code>Person</code> eingeben <p>Erstelle ein zweites Formular <code>FrmPersonEdit</code>, in dem <code>Name</code> und <code>Geburtsjahr</code> eingegeben werden. \u00d6ffne es modal (<code>ShowDialog</code>) und \u00fcbernimm die Daten zur\u00fcck ins Hauptformular.</p> <p>Hinweis</p> <ul> <li>\u00dcbergabe \u00fcber \u00f6ffentliche Properties des Dialogs.</li> </ul> L\u00f6sung <pre><code>// In FrmPersonEdit\npublic string PersonName { get; set; } = \"\";\npublic int Geburtsjahr { get; set; } = 2000;\n// OK-Button: Werte aus Controls in Properties schreiben; DialogResult = OK;\n\n// Im Hauptformular:\nprivate void CmdEdit_Click(object sender, EventArgs e)\n{\n    using var dlg = new FrmPersonEdit();\n    if (dlg.ShowDialog() == DialogResult.OK)\n    {\n        LblAnzeige.Text = $\"{dlg.PersonName} ({dlg.Geburtsjahr})\";\n    }\n}\n</code></pre> Klassenbibliothek \u2013 Modell auslagern <p>Lege ein zweites Projekt vom Typ Klassenbibliothek an und verschiebe deine Klassen (<code>Person</code>, <code>Figur</code>, \u2026) dorthin. Referenziere die Bibliothek im WinForms\u2011Projekt und verwende die Typen wie zuvor.</p> <p>Akzeptanzkriterium</p> <ul> <li>Das WinForms\u2011Projekt kompiliert, obwohl die Klassen im Bibliotheksprojekt liegen.</li> </ul> L\u00f6sung <pre><code>// kein spezifischer Code \u2013 Projektstruktur und Referenzen sind hier die \u00dcbung\n</code></pre>"},{"location":"content/6/","title":"6 Wichtige .NET\u2011Klassen","text":"string\u2011APIs \u2013 Trimmen, Ersetzen, Splitten <p>Lies einen Text aus <code>TxtRaw</code> ein und bereite ihn auf:</p> <ul> <li><code>Trim()</code> f\u00fchrende/folgende Leerzeichen entfernen</li> <li><code>Replace(\"  \", \" \")</code> doppelte Spaces vereinfachen</li> <li><code>Split(' ')</code> in W\u00f6rter zerlegen und Anzahl z\u00e4hlen</li> </ul> <p>Zeige Ergebnistext und Wortanzahl an.</p> L\u00f6sung <pre><code>string raw = TxtRaw.Text;\nstring cleaned = raw.Trim();\nwhile (cleaned.Contains(\"  \")) cleaned = cleaned.Replace(\"  \", \" \");\n\nvar words = cleaned.Split(' ', StringSplitOptions.RemoveEmptyEntries);\nLblAnzeige.Text = cleaned + \"\\n\" + $\"W\u00f6rter: {words.Length}\";\n</code></pre> DateTime &amp; TimeSpan \u2013 F\u00e4lligkeit berechnen <p>Lies ein Startdatum (<code>DateTimePicker DtpStart</code>) und eine Frist in Tagen (<code>NumTage</code>) ein.</p> <ul> <li>Berechne das F\u00e4lligkeitsdatum: <code>start + tage</code></li> <li>Zeige an, wie viele Tage ab heute noch verbleiben (negativ, wenn \u00fcberf\u00e4llig).</li> </ul> L\u00f6sung <pre><code>DateTime start = DtpStart.Value.Date;\nint tage = (int)NumTage.Value;\nDateTime faellig = start.AddDays(tage);\n\nint diff = (faellig - DateTime.Today).Days;\nLblAnzeige.Text = $\"F\u00e4llig am: {faellig:d}\\nResttage: {diff}\";\n</code></pre> Dateien \u2013 Text speichern &amp; laden <p>Implementiere Speichern und Laden f\u00fcr einen Text aus <code>TxtInhalt</code> in eine Datei <code>notiz.txt</code> im Programmverzeichnis.</p> <ul> <li><code>File.WriteAllText</code></li> <li><code>File.ReadAllText</code></li> </ul> <p>Fehler (z.\u202fB. fehlende Rechte) sollen als Meldung erscheinen.</p> L\u00f6sung <pre><code>using System.IO;\n\nprivate void CmdSave_Click(object sender, EventArgs e)\n{\n    try { File.WriteAllText(\"notiz.txt\", TxtInhalt.Text); }\n    catch (Exception ex) { MessageBox.Show(ex.Message, \"Speicherfehler\"); }\n}\n\nprivate void CmdLoad_Click(object sender, EventArgs e)\n{\n    try { TxtInhalt.Text = File.ReadAllText(\"notiz.txt\"); }\n    catch (Exception ex) { MessageBox.Show(ex.Message, \"Ladefehler\"); }\n}\n</code></pre> CSV \u2013 einfache Liste importieren/exportieren <p>Speichere eine Liste von Personen (<code>Name;Jahr</code>) als CSV\u2011Datei und lade sie wieder.</p> <ul> <li>Beim Speichern: jede Person in eine Zeile schreiben</li> <li>Beim Laden: Zeilen splitten und Personenliste in einer <code>ListBox</code> anzeigen</li> </ul> L\u00f6sung <pre><code>using System.IO;\n\nprivate List&lt;Person&gt; personen = new();\n\nprivate void CmdExport_Click(object sender, EventArgs e)\n{\n    File.WriteAllLines(\"personen.csv\", personen.Select(p =&gt; $\"{p.Name};{p.Geburtsjahr}\"));\n}\n\nprivate void CmdImport_Click(object sender, EventArgs e)\n{\n    personen = File.ReadAllLines(\"personen.csv\")\n                   .Select(l =&gt; l.Split(';'))\n                   .Select(a =&gt; new Person(a[0], int.Parse(a[1])))\n                   .ToList();\n    Lst.Items.Clear();\n    Lst.Items.AddRange(personen.Select(p =&gt; p.ToString()).ToArray());\n}\n</code></pre> XML \u2013 einfache Struktur speichern/laden <p>Speichere eine kleine Konfiguration als XML und lade sie wieder.</p> <p>Beispielstruktur</p> <ul> <li><code>&lt;config&gt;</code></li> <li><code>&lt;window title=\"...\" width=\"...\" height=\"...\"/&gt;</code></li> <li><code>&lt;/config&gt;</code></li> </ul> L\u00f6sung <pre><code>using System.Xml.Linq;\n\nprivate void CmdXmlSave_Click(object sender, EventArgs e)\n{\n    var doc = new XDocument(\n        new XElement(\"config\",\n            new XElement(\"window\",\n                new XAttribute(\"title\", this.Text),\n                new XAttribute(\"width\", this.Width),\n                new XAttribute(\"height\", this.Height)\n            )\n        )\n    );\n    doc.Save(\"config.xml\");\n}\n\nprivate void CmdXmlLoad_Click(object sender, EventArgs e)\n{\n    var doc = XDocument.Load(\"config.xml\");\n    var win = doc.Root!.Element(\"window\")!;\n    this.Text = (string)win.Attribute(\"title\")!;\n    this.Width = (int)win.Attribute(\"width\")!;\n    this.Height = (int)win.Attribute(\"height\")!;\n}\n</code></pre> Math \u2013 Funktionswerte in ListBox <p>Berechne f\u00fcr <code>x = -3 \u2026 +3</code> in 0,5\u2011Schritten die Werte <code>f(x) = sin(x) + cos(x)</code> und zeige sie formatiert in einer <code>ListBox</code>.</p> L\u00f6sung <pre><code>Lst.Items.Clear();\nfor (double x = -3; x &lt;= 3.001; x += 0.5)\n{\n    double y = Math.Sin(x) + Math.Cos(x);\n    Lst.Items.Add($\"x={x,4:F1}  f(x)={y,7:F3}\");\n}\n</code></pre> DateTimePicker \u2013 Zeitraumdiff in Stunden/Minuten <p>Nutze zwei <code>DateTimePicker</code> (<code>DtpVon</code>, <code>DtpBis</code>) und berechne Differenzen:</p> <ul> <li>Gesamtdauer in Tagen</li> <li>in Stunden</li> <li>in Minuten</li> </ul> L\u00f6sung <pre><code>DateTime von = DtpVon.Value;\nDateTime bis = DtpBis.Value;\nvar span = bis - von;\n\nLblAnzeige.Text = $\"Tage: {span.TotalDays:F2}\\nStunden: {span.TotalHours:F2}\\nMinuten: {span.TotalMinutes:F0}\";\n</code></pre> Verzeichnisse \u2013 Liste der Dateien anzeigen <p>Zeige alle Dateien eines Ordners in einer <code>ListBox</code> an. Nutze <code>FolderBrowserDialog</code> zur Auswahl.</p> L\u00f6sung <pre><code>using System.IO;\n\nprivate void CmdPickFolder_Click(object sender, EventArgs e)\n{\n    using var dlg = new FolderBrowserDialog();\n    if (dlg.ShowDialog() == DialogResult.OK)\n    {\n        Lst.Items.Clear();\n        foreach (var f in Directory.GetFiles(dlg.SelectedPath))\n            Lst.Items.Add(f);\n    }\n}\n</code></pre>"},{"location":"content/7/","title":"7 Weitere Windows\u2011Form\u2011Elemente","text":"Men\u00fc &amp; Statusleiste \u2013 einfache Befehle <p>Erstelle ein Men\u00fc mit Eintr\u00e4gen Datei \u2192 Neu, \u00d6ffnen, Speichern, Beenden und eine Statusleiste. Zeige beim Klicken jeweils eine Statusmeldung an.</p> L\u00f6sung <pre><code>private void mnuNeu_Click(object sender, EventArgs e)    =&gt; toolStripStatusLabel1.Text = \"Neu\";\nprivate void mnuOeffnen_Click(object sender, EventArgs e)=&gt; toolStripStatusLabel1.Text = \"\u00d6ffnen\";\nprivate void mnuSpeichern_Click(object sender, EventArgs e)=&gt; toolStripStatusLabel1.Text = \"Speichern\";\nprivate void mnuBeenden_Click(object sender, EventArgs e) =&gt; Close();\n</code></pre> Kontextmen\u00fc \u2013 Rechtsklick auf Label <p>F\u00fcge einem <code>Label</code> ein Kontextmen\u00fc (Rechtsklick) mit \u201eKopieren\u201c und \u201eL\u00f6schen\u201c hinzu.</p> L\u00f6sung <pre><code>private void ctxCopy_Click(object sender, EventArgs e) { Clipboard.SetText(LblAnzeige.Text); }\nprivate void ctxClear_Click(object sender, EventArgs e) { LblAnzeige.Text = \"\"; }\n</code></pre> Standarddialoge \u2013 Datei \u00f6ffnen/speichern <p>Implementiere <code>OpenFileDialog</code> und <code>SaveFileDialog</code> zum Laden/Speichern von Text in <code>RichTextBox</code>.</p> L\u00f6sung <pre><code>private void CmdOpen_Click(object sender, EventArgs e)\n{\n    using var dlg = new OpenFileDialog { Filter = \"Text|*.txt|Alle|*.*\" };\n    if (dlg.ShowDialog() == DialogResult.OK)\n        richTextBox1.Text = File.ReadAllText(dlg.FileName);\n}\n\nprivate void CmdSave_Click(object sender, EventArgs e)\n{\n    using var dlg = new SaveFileDialog { Filter = \"Text|*.txt\" };\n    if (dlg.ShowDialog() == DialogResult.OK)\n        File.WriteAllText(dlg.FileName, richTextBox1.Text);\n}\n</code></pre> RichTextBox \u2013 Formatierungen anwenden <p>Erstelle Buttons Fett, Kursiv, Unterstrichen, die auf die aktuelle Auswahl in <code>RichTextBox</code> wirken.</p> L\u00f6sung <pre><code>private void ToggleStyle(FontStyle style)\n{\n    var sel = richTextBox1.SelectionFont ?? richTextBox1.Font;\n    var newStyle = sel.Style ^ style;\n    richTextBox1.SelectionFont = new Font(sel, newStyle);\n}\n\nprivate void CmdBold_Click(object s, EventArgs e) =&gt; ToggleStyle(FontStyle.Bold);\nprivate void CmdItalic_Click(object s, EventArgs e) =&gt; ToggleStyle(FontStyle.Italic);\nprivate void CmdUnderline_Click(object s, EventArgs e) =&gt; ToggleStyle(FontStyle.Underline);\n</code></pre> DataGridView \u2013 Liste binden &amp; editieren <p>Binde eine <code>BindingList&lt;Person&gt;</code> an ein <code>DataGridView</code>, damit Eintr\u00e4ge direkt editiert werden k\u00f6nnen.</p> L\u00f6sung <pre><code>using System.ComponentModel;\n\nprivate BindingList&lt;Person&gt; data = new BindingList&lt;Person&gt;\n{\n    new Person(\"Alex\", 1992),\n    new Person(\"Sam\", 1988),\n};\n\nprivate void Form1_Load(object sender, EventArgs e)\n{\n    dataGridView1.DataSource = data;\n}\n</code></pre> ListView \u2013 Detailsansicht mit Spalten <p>F\u00fclle eine <code>ListView</code> in Details\u2011Ansicht mit zwei Spalten (Name, Jahr) und einigen Eintr\u00e4gen.</p> L\u00f6sung <pre><code>private void CmdFill_Click(object sender, EventArgs e)\n{\n    listView1.View = View.Details;\n    listView1.Columns.Clear();\n    listView1.Columns.Add(\"Name\", 120);\n    listView1.Columns.Add(\"Jahr\", 60);\n\n    listView1.Items.Clear();\n    listView1.Items.Add(new ListViewItem(new[] {\"Alex\", \"1992\"}));\n    listView1.Items.Add(new ListViewItem(new[] {\"Sam\", \"1988\"}));\n}\n</code></pre> Lokalisierung \u2013 UI\u2011Text wechseln <p>Simuliere eine einfache \u201eLokalisierung\u201c, indem du Texte von Steuerelementen zwischen Deutsch/Englisch umschaltest.</p> L\u00f6sung <pre><code>private bool de = true;\nprivate void CmdLang_Click(object sender, EventArgs e)\n{\n    de = !de;\n    this.Text = de ? \"Meine App\" : \"My App\";\n    CmdLang.Text = de ? \"Sprache\" : \"Language\";\n}\n</code></pre> Farb-/Schriftartdialog \u2013 anwenden auf Label <p>W\u00e4hle per <code>ColorDialog</code> und <code>FontDialog</code> Farbe und Schriftart f\u00fcr <code>LblAnzeige</code> aus.</p> L\u00f6sung <pre><code>private void CmdColor_Click(object sender, EventArgs e)\n{\n    using var dlg = new ColorDialog();\n    if (dlg.ShowDialog() == DialogResult.OK) LblAnzeige.ForeColor = dlg.Color;\n}\nprivate void CmdFont_Click(object sender, EventArgs e)\n{\n    using var dlg = new FontDialog();\n    if (dlg.ShowDialog() == DialogResult.OK) LblAnzeige.Font = dlg.Font;\n}\n</code></pre> Statusleiste \u2013 Fortschritt mit Timer <p>Verwende eine <code>ToolStripProgressBar</code>, die \u00fcber einen Timer von 0 bis 100 hochl\u00e4uft.</p> L\u00f6sung <pre><code>private void Tmr_Tick(object sender, EventArgs e)\n{\n    toolStripProgressBar1.Value = Math.Min(100, toolStripProgressBar1.Value + 1);\n}\n</code></pre>"},{"location":"content/8/","title":"8 Datenbanken (SQLite)","text":"SQLite \u2013 Datenbank anlegen und Tabelle erstellen <p>Lege eine lokale SQLite\u2011Datei <code>app.db</code> an und erstelle eine Tabelle <code>persons(id INTEGER PRIMARY KEY, name TEXT, year INT)</code>.</p> <p>Hinweis</p> <ul> <li>F\u00fcge NuGet\u2011Paket <code>System.Data.SQLite</code> oder <code>Microsoft.Data.Sqlite</code> hinzu.</li> </ul> L\u00f6sung <pre><code>using System.Data.SQLite; // oder Microsoft.Data.Sqlite\n\nprivate void CmdInit_Click(object sender, EventArgs e)\n{\n    using var con = new SQLiteConnection(\"Data Source=app.db\");\n    con.Open();\n    using var cmd = con.CreateCommand();\n    cmd.CommandText = \"CREATE TABLE IF NOT EXISTS persons(id INTEGER PRIMARY KEY, name TEXT, year INT);\";\n    cmd.ExecuteNonQuery();\n}\n</code></pre> INSERT \u2013 Parameter verwenden <p>F\u00fcge einen Datensatz in <code>persons</code> ein. Werte stammen aus <code>TxtName</code> und <code>NumJahr</code>. Verwende parametrisierte SQL\u2011Befehle.</p> L\u00f6sung <pre><code>using var con = new SQLiteConnection(\"Data Source=app.db\");\ncon.Open();\nusing var cmd = con.CreateCommand();\ncmd.CommandText = \"INSERT INTO persons(name, year) VALUES(@n, @y);\";\ncmd.Parameters.AddWithValue(\"@n\", TxtName.Text);\ncmd.Parameters.AddWithValue(\"@y\", (int)NumJahr.Value);\ncmd.ExecuteNonQuery();\n</code></pre> SELECT \u2013 Liste anzeigen <p>Lade alle Personen und zeige sie in einer <code>ListBox</code> oder einem <code>DataGridView</code> an.</p> L\u00f6sung <pre><code>using var con = new SQLiteConnection(\"Data Source=app.db\");\ncon.Open();\nusing var cmd = new SQLiteCommand(\"SELECT id, name, year FROM persons ORDER BY name;\", con);\nusing var rdr = cmd.ExecuteReader();\nLst.Items.Clear();\nwhile (rdr.Read())\n{\n    Lst.Items.Add($\"{rdr.GetInt32(0)}: {rdr.GetString(1)} ({rdr.GetInt32(2)})\");\n}\n</code></pre> UPDATE \u2013 Datensatz \u00e4ndern <p>Aktualisiere <code>name</code> und <code>year</code> eines ausgew\u00e4hlten Eintrags anhand der <code>id</code>. Verwende wieder Parameter.</p> L\u00f6sung <pre><code>using var con = new SQLiteConnection(\"Data Source=app.db\");\ncon.Open();\nusing var cmd = con.CreateCommand();\ncmd.CommandText = \"UPDATE persons SET name=@n, year=@y WHERE id=@id;\";\ncmd.Parameters.AddWithValue(\"@n\", TxtName.Text);\ncmd.Parameters.AddWithValue(\"@y\", (int)NumJahr.Value);\ncmd.Parameters.AddWithValue(\"@id\", int.Parse(TxtId.Text));\ncmd.ExecuteNonQuery();\n</code></pre> DELETE \u2013 Datensatz entfernen <p>L\u00f6sche einen Eintrag anhand der <code>id</code>. Frage vorher per <code>MessageBox</code> nach Best\u00e4tigung.</p> L\u00f6sung <pre><code>if (MessageBox.Show(\"Wirklich l\u00f6schen?\", \"Best\u00e4tigen\", MessageBoxButtons.YesNo) == DialogResult.Yes)\n{\n    using var con = new SQLiteConnection(\"Data Source=app.db\");\n    con.Open();\n    using var cmd = con.CreateCommand();\n    cmd.CommandText = \"DELETE FROM persons WHERE id=@id;\";\n    cmd.Parameters.AddWithValue(\"@id\", int.Parse(TxtId.Text));\n    cmd.ExecuteNonQuery();\n}\n</code></pre> SELECT mit WHERE \u2013 Suche nach Name <p>Suche Personen per Teilstring im Namen (z.\u202fB. <code>LIKE '%' || @q || '%'</code>) und zeige Ergebnisliste an.</p> L\u00f6sung <pre><code>using var con = new SQLiteConnection(\"Data Source=app.db\");\ncon.Open();\nusing var cmd = con.CreateCommand();\ncmd.CommandText = \"SELECT id,name,year FROM persons WHERE name LIKE '%' || @q || '%' ORDER BY name;\";\ncmd.Parameters.AddWithValue(\"@q\", TxtSuche.Text);\nusing var rdr = cmd.ExecuteReader();\nLst.Items.Clear();\nwhile (rdr.Read())\n    Lst.Items.Add($\"{rdr.GetInt32(0)}: {rdr.GetString(1)} ({rdr.GetInt32(2)})\");\n</code></pre> Transaktion \u2013 mehrere Inserts atomar <p>F\u00fcge mehrere Personen in einer Transaktion ein, damit entweder alle oder keine gespeichert werden.</p> L\u00f6sung <pre><code>using var con = new SQLiteConnection(\"Data Source=app.db\");\ncon.Open();\nusing var tx = con.BeginTransaction();\nusing var cmd = con.CreateCommand();\ncmd.Transaction = tx;\ncmd.CommandText = \"INSERT INTO persons(name, year) VALUES(@n,@y);\";\ntry\n{\n    foreach (var p in new[]{(\"Alex\",1992),(\"Sam\",1988)})\n    {\n        cmd.Parameters.Clear();\n        cmd.Parameters.AddWithValue(\"@n\", p.Item1);\n        cmd.Parameters.AddWithValue(\"@y\", p.Item2);\n        cmd.ExecuteNonQuery();\n    }\n    tx.Commit();\n}\ncatch\n{\n    tx.Rollback();\n    throw;\n}\n</code></pre> DataBinding \u2013 Grid bidirektional <p>Binde ein <code>DataTable</code> an ein <code>DataGridView</code> und synchronisiere \u00c4nderungen zur\u00fcck in SQLite (einfacher Ansatz: komplette Tabelle l\u00f6schen/neu einf\u00fcgen).</p> L\u00f6sung <pre><code>using System.Data;\n\n// Lesen\nusing var con = new SQLiteConnection(\"Data Source=app.db\");\ncon.Open();\nusing var da = new SQLiteDataAdapter(\"SELECT id,name,year FROM persons;\", con);\nvar dt = new DataTable();\nda.Fill(dt);\ndataGridView1.DataSource = dt;\n</code></pre>"},{"location":"content/9/","title":"9 GDI+ Zeichnen","text":"Linien &amp; Rechtecke zeichnen <p>Zeichne im <code>Paint</code>\u2011Ereignis der Form einige Linien und ein gef\u00fclltes Rechteck.</p> L\u00f6sung <pre><code>private void Form1_Paint(object sender, PaintEventArgs e)\n{\n    var g = e.Graphics;\n    g.DrawLine(Pens.Black, 10, 10, 200, 10);\n    g.DrawRectangle(Pens.Blue, 20, 30, 120, 80);\n    g.FillRectangle(Brushes.LightBlue, 22, 32, 116, 76);\n}\n</code></pre> Kreis/Ellipse &amp; Text <p>Zeichne eine Ellipse und schreibe einen Text mittig darunter.</p> L\u00f6sung <pre><code>private void Form1_Paint(object sender, PaintEventArgs e)\n{\n    var g = e.Graphics;\n    var rect = new Rectangle(50, 50, 150, 100);\n    g.DrawEllipse(Pens.DarkGreen, rect);\n    g.DrawString(\"Ellipse\", this.Font, Brushes.Black, rect.Left, rect.Bottom + 5);\n}\n</code></pre> Mauszeichnen \u2013 freih\u00e4ndig <p>Implementiere Zeichnen per Maus: Beim Dr\u00fccken beginnen, bei Bewegung Liniensegmente hinzuf\u00fcgen, beim Loslassen stoppen.</p> L\u00f6sung <pre><code>private bool drawing = false;\nprivate Point last;\n\nprivate void Form1_MouseDown(object sender, MouseEventArgs e) { drawing = true; last = e.Location; }\nprivate void Form1_MouseUp(object sender, MouseEventArgs e) { drawing = false; }\nprivate void Form1_MouseMove(object sender, MouseEventArgs e)\n{\n    if (!drawing) return;\n    using var g = this.CreateGraphics();\n    g.DrawLine(Pens.Black, last, e.Location);\n    last = e.Location;\n}\n</code></pre> DoubleBuffering \u2013 Flackern vermeiden <p>Aktiviere <code>DoubleBuffered = true</code> in der Form (oder Panel), um Flackern bei Animationen zu reduzieren.</p> L\u00f6sung <pre><code>public Form1()\n{\n    InitializeComponent();\n    this.DoubleBuffered = true;\n}\n</code></pre> Bild zeichnen <p>Lade ein Bild aus Datei und zeichne es skaliert in die Form.</p> L\u00f6sung <pre><code>private Image? _img;\n\nprivate void CmdLoadImg_Click(object sender, EventArgs e)\n{\n    using var dlg = new OpenFileDialog { Filter = \"Bilder|*.png;*.jpg;*.jpeg;*.bmp\" };\n    if (dlg.ShowDialog() == DialogResult.OK) _img = Image.FromFile(dlg.FileName);\n    Invalidate();\n}\n\nprivate void Form1_Paint(object sender, PaintEventArgs e)\n{\n    if (_img != null)\n    {\n        var g = e.Graphics;\n        g.DrawImage(_img, new Rectangle(10,10,200,150));\n    }\n}\n</code></pre> Funktionsplot y = sin(x) <p>Zeichne die Kurve <code>y = sin(x)</code> im Bereich <code>x = 0 \u2026 2\u03c0</code> in ein Koordinatensystem.</p> L\u00f6sung <pre><code>private void Form1_Paint(object sender, PaintEventArgs e)\n{\n    var g = e.Graphics;\n    int w = this.ClientSize.Width;\n    int h = this.ClientSize.Height;\n    PointF[] pts = new PointF[w];\n    for (int x = 0; x &lt; w; x++)\n    {\n        double t = (double)x / (w - 1) * 2 * Math.PI;\n        double y = Math.Sin(t);\n        float yy = (float)((1 - (y + 1) / 2) * (h - 1));\n        pts[x] = new PointF(x, yy);\n    }\n    g.DrawLines(Pens.Red, pts);\n}\n</code></pre> Persistentes Zeichnen \u2013 Liste von Formen <p>Verwalte gezeichnete Formen in einer Liste und zeichne sie im <code>Paint</code> neu, statt sofort mit <code>CreateGraphics</code>.</p> L\u00f6sung <pre><code>private readonly List&lt;Rectangle&gt; rects = new();\n\nprivate void CmdAddRect_Click(object s, EventArgs e)\n{\n    rects.Add(new Rectangle(10 + 20*rects.Count, 10, 40, 30));\n    Invalidate();\n}\n\nprivate void Form1_Paint(object sender, PaintEventArgs e)\n{\n    foreach (var r in rects) e.Graphics.DrawRectangle(Pens.Black, r);\n}\n</code></pre>"}]}